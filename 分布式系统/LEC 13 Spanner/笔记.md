# spanner

针对分布范围很广的分离数据的分布式事务

1:使用两阶段提交

2:为防止崩溃导致所有人阻塞，在spanner使用了paxos

通过同步时间来做到高效**只读**事务(强一致性)

例如有三个数据中心DC1,DC2,DC3，数据是分布存储的

每个数据中心有多个spanner client(web server)

副本的管理是由paxos(的一种变体)

数据会进行分组(比如key为a开头的分为一个paxos组)

每个组都有自己的leader，各自维护独立的数据版本协议，为了提高并行和数据安全，

# 挑战

1:很想从本地数据中心读取，但本地数据中心不是leader，或是旧版本(paxos只需要复制大部分即可)

2:一个事务涉及到多个数据分片(paxos组)，所以需要分布式事务(两段提交)

# 读写型事务

比如银行转账demo，让x-1,y+1

如果x,y在不同paxos组中，同时数据分片被复制到3个不同的数据中心

```
dc1 dc2 dc3
x   x   x
y   y   y
```

为了实现两阶段锁和两阶段提交，需要用多台服务器组成的paxos组当参与者和事务协调器。以提高容错

假设dc2是x的leader,dc1是y的leader

client选择一个唯一事务id给要发送的消息打上标记

1:client向x的leader发送读请求，leader会尝试上锁，再返回当前值。向y请求读

2:计算完成后,client会选择其中一个paxos组作为事务协调器，然后将更新值(包含选择的paxos组id)发给leader，会把所有写操作一次性提交给paxos组。

3:当paxos组中的leader收到写请求时，会发送prepare消息给follower，然后写入paxos日志。当收到大部分YES后，leader发送YES给事务协调器，

4:当协调者收到所有YES后，commit,否者就不commit

5：收到commit后，leader再把commit消息发给follwer,告知可以提交

当commit落地到日志后，协调器才会将commit消息发到其他数据分片的paxos组

事件结束后解锁

如果事务协调器故障，事务就会一直阻塞(还带着锁)，spanner通过对事务协调器的复制解决了这个问题:

如果leader崩了，那么replica中任意一个就能接手继续leader的工作(和事务协调器的工作，基于日志)

# 只读事务

1:能并行，只读事务只能看见执行前那个事务中所有写操作执行的结果。看不到后面的。所以需要一种方法把只读事务放在读写事务的中间。

2:外部的线性一致性，

解决方法

快照隔离，所有机器上有同步时钟，对于只读事务，其时间戳是事务开始时间，每个事务中涉及的数据也有其自己的时间戳。

当replica保存数据时，实际保存了该数据的多个版本

读操作会根据发起时间来寻找最新数据

# 从本地数据中心读取

为防止本地数据中心是少数派，设定了安全时间。replica会记录从lieader收到的日志上的时间戳。如果要去读取时间戳15对应值，但repilica只有时间戳13，replica会推迟，直到其获取到15后才会响应。

# 时钟同步问题

如果快照隔离不同步，对读写事务没有影响。

如果只读事务选择了一个很大的时间戳，reader会被迫离开(超时)

如果过小，会丢失许多操作

时钟同步问题:

当follower向time leader请求当前时间时，实际拿到的是一个TT区间的东西(earliest time 和latest time组成)

start rule:

(读写或只读)事务的时间戳是latest time，

commit wait:

只适用读写，事务协调器会收集投票信息，并检查是否能提交事务， 并为此选择一个提交时间戳。实际提交事务之前，需要延迟等待一段实际。需要到达它选择的的那个时间戳为止，同时这个时间戳小于下一个读事务当前时间的最小开始时间(earlest time)。