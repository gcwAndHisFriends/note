# 分布式事务

事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。

并发控制，原子性提交，合成事务

比如转账

第一个事务

```
begin_x
add(x,1)
add(y,-1)
end_x
```

第二个事务，审计，只读事物，判断总额是否变化

```
begin_x
a=get(x)
b=get(y)
print(a,b)
end_x
```

ACID

A:atomic 原子性,要么全执行，要么全不执行

Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

I: 隔离性,事务无法互相看见中间值

D:持久化，事务提交后，所做的修改是持久的

并发控制解决方案

悲观锁并发控制:传统锁

乐观锁:无需担心竞争，将结果写入临时区域，到最后再检查是否有其他事务对我们的事务造成影响

两阶段锁(悲观)

1:数据读取写入前，要获取对应锁

2:事务提交或终止后才能释放锁

原子提交协议

确保事务被完整提交或回滚的协议

比如转账，电脑A对X＋1，电脑B对Y-1,有事务调节器C

C给A,B发送对应消息，根据回应判断是否完成，并决定下一步操作(撤销还是完成 )

具体的:

1:给参与者发送put/get信息，参与者上锁，返回yes给协调者

2:协调者发送prepare消息给所有参与者

3:参与者收到prepare后，判断自己能否解决这个事务，返回YES或no

4:如果都是YES，就给每个参与者发送commit信息。只要有一个返回NO，就不会commit,并返回abort信息，要求回滚

当参与者接收put/get时，就会开始锁，知道commit或abord结束后才会解锁(锁是由事务持有的)

故障分析

1:执行prepare后，把yes发回之前崩溃，根据commit机制，不会出现什么问题

2:返回YES之后，收到commit之前，发生崩溃:参与者崩溃恢复后，不知道是否收到了commit，依旧在等待。为此，要将内存中事务锁管理数据的中间状态(做的修改)持久化到磁盘，以防止崩溃终止。也就是在参与者返回YES来回复prepare之前，就要把所需信息写到磁盘日志

3:收到commit，提交完事务后发生崩溃，(没有返回YES)，由于修改(或预写日志)已经落地在磁盘了

4:如果发送commit时协调者崩溃，那么协调者必须重启并重新发送commit

5:协调者发送一部分commit时崩溃，那么就要将事务先写在磁盘，再发送换句话说，接收者需要做好重复接收commit的准备。

6网络问题:

1:协调器发送prepare，没收到结果，所以发一组新的。如果一个参与者掉线太久，可能中止事务

2:参与者等待prepare超时，允许中止事物(因为没返回yes，协调者也无法commit)

3：收到prepare，返回yes，但没收到commit或abort，他此时持有锁。但无权单方面中止事务。必须一直等下去(阻塞)

4:
