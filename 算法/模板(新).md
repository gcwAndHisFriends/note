# 基础

## 快速幂

## 最大公约数

## 线性筛法

## 扩展欧几里得

```
int qmi(int a, int k) {
int ans = 1 ;
while (k) {
if (k & 1 )
ans = ans * a;
k >>= 1 ;
a = a * a ;
}
return ans;
}
int gcd(int a, int b)
{
return b? gcd(b, a % b) : a;
}
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2 ; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0 ; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0 ) break;
}
}
}
//定 n 对正整数 ai,bi，对于每对数，求出一组 xi,yi，使其满足 ai×xi+bi×yi=gcd(ai,bi)。
#include <bits/stdc++.h>
```

## 组合数

```
using namespace std;
const int N = 1010 ;
int exgcd(int a, int b, int &x, int &y) {
if (!b) {
x = 1 , y = 0 ;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= a / b * x;
return d;
}
void solve() {
int a, b, x, y;
cin >> a >> b;
exgcd(a, b, x, y);
cout << x<<" " << y << endl;
}
int main() {
int t;
cin >> t;
while (t--)
solve();
}
const int N= 2010 ,mod=1e9+ 7 ;
int c[N][N];
void inti()
{
for(int i= 0 ;i<N;i++)
{
for(int j= 0 ;j<=i;j++)
{
if(!j)c[i][j]= 1 ;
else c[i][j]=(c[i- 1 ][j]+c[i- 1 ][j- 1 ])%mod;
}
}
}
const int N = 100010 , mod = 1e9 + 7 ;
int fact[N], infact[N];
int qmi(int a, int k, int p) {
int res = 1 ;
while (k) {
if (k & 1 )
res = res * a % p;
a = a * a % p;
k >>= 1 ;
}
return res;
#### }

void init(){
fact[ 0 ] = infact[ 0 ] = 1 ;
for (int i = 1 ; i < N; i++) {
fact[i] = fact[i - 1 ] * i % mod;
infact[i] = infact[i - 1 ] * qmi(i, mod - 2 , mod) % mod;
}
}
int get(int a,int b){
return fact[a]*infact[b] % mod *infact[a - b] % mod;
}

int qmi(int a, int k) {
int res = 1 ;
while (k) {
if (k & 1 )
res = res * a % p;
a = a * a % p;
k >>= 1 ;
}
return res;
}

int C(int a, int b) {
if(b>a)return 0 ;
int res = 1 ;
for (int i = 1 , j = a; i <= b; i++, j--) {
res = res * j % p;
res = res * qmi(i, p - 2 )%p;
}
return res;
}

int lucas(int a, int b) {
if (a < p && b < p) {
return C(a, b); //从定义出发来算
}
return C(a % p, b % p) * lucas(a / p, b / p) % p;
}

输入 a,b，求 Cba 的值。

注意结果可能很大，需要使用高精度计算。
using namespace std;
const int N = 5010 ;
int primes[N], cnt;
int sum[N];
bool st[N];
void get_primes(int n)
{
for (int i = 2 ; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0 ; primes[j] <= n / i; j ++ )

#### {

st[primes[j] * i] = true;
if (i % primes[j] == 0 ) break;
}
}
}
int get(int n, int p)
{
int res = 0 ;
while (n)
{
res += n / p;
n /= p;
}
return res;
}
vector mul(vector a, int b)
{
vector c;
int t = 0 ;
for (int i = 0 ; i < a.size(); i ++ )
{
t += a[i] * b;
c.push_back(t % 10 );
t /= 10 ;
}
while (t)
{
c.push_back(t % 10 );
t /= 10 ;
}
return c;
}
int main(){
int a, b;
cin >> a >> b;

get_primes(a);

for (int i = 0 ; i < cnt; i ++ )
{
int p = primes[i];
sum[i] = get(a, p) - get(a - b, p) - get(b, p);
}

vector res;
res.push_back( 1 );

for (int i = 0 ; i < cnt; i ++ )
for (int j = 0 ; j < sum[i]; j ++ )
res = mul(res, primes[i]);

for (int i = res.size() - 1 ; i >= 0 ; i -- ) printf("%d", res[i]);
puts("");

return 0 ;
}
```



## 高精度

```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);
vector<int> C;
int t = 0 ;
for (int i = 0 ; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10 );
t /= 10 ;
}
if (t) C.push_back(t);
return C;
}
bool cmp(vector<int> &A, vector<int> &B)
{
if (A.size() != B.size()) return A.size() > B.size();
for (int i = A.size() - 1 ; i >= 0 ; i -- )
if (A[i] != B[i])
return A[i] > B[i];
return true;
}
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0 , t = 0 ; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10 ) % 10 );
if (t < 0 ) t = 1 ;
else t = 0 ;
}
while (C.size() > 1 && C.back() == 0 ) C.pop_back();
return C;
}
int main()
{
string a, b;
vector<int> A, B;
cin >> a >> b;
for (int i = a.size() - 1 ; i >= 0 ; i -- ) A.push_back(a[i] - '0');
for (int i = b.size() - 1 ; i >= 0 ; i -- ) B.push_back(b[i] - '0');
```

## DP

```
vector<int> C;
if (cmp(A, B)) C = sub(A, B);
else C = sub(B, A), cout << '-';
for (int i = C.size() - 1 ; i >= 0 ; i -- ) cout << C[i];
cout << endl;
return 0 ;
}
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0 ;
for (int i = 0 ; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10 );
t /= 10 ;
}
while (C.size() > 1 && C.back() == 0 ) C.pop_back();
return C;
}
//给定两个非负整数（不含前导 0 ） A，B，请你计算 A/B 的商和余数。
```

#### 

```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0 ;
for (int i = A.size() - 1 ; i >= 0 ; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0 ) C.pop_back();
return C;
}
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;
int n, m;
const int N = 1e2 + 10 ;
int a[N], s[N];
int ans = 1e8;
```

int dp[N][N];//让前i个人拿,最后取的一包糖是第j包,最大的值为K
void solve() {
cin >> n >> m; //将n分成m组
for (int i = 1 ; i <= n; i++) {
cin >> a[i];
s[i] = a[i] + s[i - 1 ];
}
int ans = 1e8;

for (int mi = 1 ; mi <= s[n] / m + 1 ; mi++) { //每个人能分到的最小值
memset(dp, 0x3f, sizeof dp);
dp[ 0 ][ 0 ] = 0 ;//让前i个人拿,第i人取的最后一包糖是第j包
for (int i = 1 ; i <= m; i++) {
for (int j = i; j <= n - (m - i); j++) { //第i人取的最后一包
for (int k = i; k <= j; k++) { //第i人取的第一包
int sum = s[j] - s[k - 1 ]; //s是前缀和
if (sum >= mi) { //要满足最低要求
dp[i][j] = min(dp[i][j], max(dp[i - 1 ][k - 1 ], sum));
}
}
}
}
ans = min(ans, dp[m][n] - mi);
}
cout << ans << endl;
}

signed main() {
ios::sync_with_stdio(false);

solve();
}

\#pragma GCC optimize(2)
\#include <bits/stdc++.h>
\#define int long long
\#define endl '\n'
using namespace std;
const int N = 1e6;
int n, m;
int a[N];

int s[N];//第i组分得几个
int ans = 1e8;
void check() {
int maxn = - 1e8, minn = 1e8;
int idx = 1 ;
for (int i = 1 ; i <= m; i++) {
int sum = 0 , num = 1 ;
while (num <= s[i]) {
sum += a[idx++];
num++;
}
maxn = max(maxn, sum);
minn = min(minn, sum);

#### }

ans = min(ans, maxn - minn);
}

void dfs(int u, int sum) {
if (sum > n)
return;
if (u == m + 1 ) {
if (sum == n)
check();
return ;
}
for (int i = 1 ; i + sum <= n; i++) { //第u人拿几个
s[u] = i;
dfs(u + 1 , i + sum);
}
}

void solve() {
cin >> n >> m; //将n分成m组
for (int i = 1 ; i <= n; i++)
cin >> a[i];
dfs( 1 , 0 );
cout << ans << endl;
}

signed main() {
ios::sync_with_stdio(false);

solve();
}

\#pragma GCC optimize(2)
\#include <bits/stdc++.h>
\#define int long long
\#define endl '\n'
using namespace std;

int n, m;
const int N = 1e6;
int a[N];
int ans = 1e16;

bool check(int x) {
int maxn = 0 ; //最大值
int idx = 1 ; //当前用到了哪一个
for (int i = 1 ; i <= m; i++) {
int num = 0 ; //这个人已经累计到了多少个礼物了
if (i == m) { //最后一个小朋友必须要把剩下的拿完
if (idx > n)
return false;
else {
for (int j = idx; j <= n; j++) {

num += a[j];
}
if (num < x)
return false;
else {
maxn = max(maxn, num);
ans = min(ans, maxn - x);
return true;
}
}
} else {
while (num < x && idx <= n)
num += a[idx++];
maxn = max(maxn, num);
if (idx > n)
return false;//还需要给第m个人留一个
}

}
return true;//事实上这个是不执行地
}

void solve() {
cin >> n >> m;
int allnum = 0 ;
for (int i = 1 ; i <= n; i++) {
cin >> a[i];
allnum += a[i];
}
if (n < m) {
cout << "-1" << endl; //没有合理方案
}
int l = 1 , r = 1e9; //二分每个人最小价值
int pre = 0 ;//上一个mid值
//如果不用pre,二分可能会跳过一些值
while (l < r ) {
int mid = l + r >> 1 ;
if (mid == pre)
break;
cout << "A: " << l << " " << r << " " << mid << endl;
if (check(mid)) { //该方案是可行的
l = mid; //提高最小值，也能降低最大值
} else {
r = mid ;
}
pre = mid;
cout << "B: " << l << " " << r << " " << mid << endl;
cout << "ans: " << ans << endl;
}
cout << ans << endl;

#### }

signed main() {

ios::sync_with_stdio(false);

solve();
}

\#pragma GCC optimize(2)
\#include <bits/stdc++.h>
\#define int long long
\#define endl '\n'
using namespace std;

int n, m;
const int N = 1e6;
int a[N];
int ans = 1e8;

int check(int x) {
int maxn = 0 ; //最大值
int idx = 1 ; //当前用到了哪一个
for (int i = 1 ; i <= m; i++) {
int num = 0 ; //这个人已经累计到了多少个数了
if (i == m) { //最后一个组必须要把剩下的拿完
if (idx > n)
return false;
else {
for (int j = idx; j <= n; j++) {
num += a[j];
}
if (num < x)
return false;
else {
maxn = max(maxn, num);
return maxn;
}
}
} else {
while (num < x && idx <= n)
num += a[idx++];
maxn = max(maxn, num);
if (idx > n)
return false;//还需要给第m个人留一个
}

}
return true;
}

void solve() {
cin >> n >> m;
int allnum = 0 ;
for (int i = 1 ; i <= n; i++) {
cin >> a[i];
allnum += a[i];
}

## 归并排序求逆序

```
if (n < m) {
cout << "-1" << endl; //没有合理方案
}
int l = 1 , r = allnum / m + 1 ;
for (int i = 1 ; i <= allnum / m + 1 ; i++) {//枚举每一组的最小值
int num = check(i);
if (num) {
ans = min(ans, num - i);
}
}
cout << ans << endl;
```

#### }

```
signed main() {
ios::sync_with_stdio(false);
solve();
}
int q[N];
long long ans= 0 ;
int tmp[N];//辅助数组
void merge_sort(int q[], int l, int r) {
if (l >= r)
return ;
int mid = l + r >> 1 ;
merge_sort(q, l, mid), merge_sort(q, mid + 1 , r);
int k = 0 ; //两个序列合并时已经合并了的数的数量
int i = l, j = mid + 1 ;
while (i <= mid && j <= r) {
if (q[i] <= q[j]) {
tmp[k++] = q[i++];
} else {
ans+=mid-i+ 1 ;//逆序
tmp[k++] = q[j++];
}
}
while (i <= mid)
tmp[k++] = q[i++];
while (j <= r)
tmp[k++] = q[j++];
for (int i = l, j = 0 ; i <= r; i++, j++)
q[i] = tmp[j];
}
```

## 模拟退火

```
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<double, double >PDD;
const int N = 110 ;
int n;
PDD q[N];//
double ans = 1e8;
double rand(double l, double r) { //随机一个浮点数
return (double)rand() / RAND_MAX * (r - l) + l;
}
double get_dist(PDD a, PDD b) { //求两个点距离
double dx = a.x - b.x;
double dy = a.y - b.y;
return sqrt(dx * dx + dy * dy);
}
double calc(PDD p) { //求全局总距离和
double res = 0 ;
for (int i = 0 ; i < n; i++) {
res += get_dist(p, q[i]);
}
ans = min(ans, res);
return res;
}
void simulate_anneal() {
PDD cur(rand( 0 , 10000 ), rand( 0 , 10000 )); //初始点
for (double t = 1e4; t > 1e- 4 ; t *= 0.99) {
PDD np(rand(cur.x - t, cur.x + t), rand(cur.y - t, cur.y + t)); //随机一个
新点
auto dt = calc(np) - calc(cur); //新旧点距离差
if (exp(-dt / t) > rand( 0 , 1 ))
cur = np; //e^(-dt/t) 如果dt>0，exp必定大于1,如果dt<0，exp必定大于 0 小于 1
```

#### }

#### }

```
int main() {
cin >> n;
for (int i = 0 ; i < n; i++)
cin >> q[i].x >> q[i].y;
for (int i = 0 ; i < 100 ; i++) { //模拟一百次
simulate_anneal();
}
printf("%.0lf\n",ans);
return 0 ;
}
```

## 归并排序逆序对

## RMQ

```
int merge(int l ,int r)
{
if (l >= r) return 0 ;
int mid = (l + r) >> 1 ;
int ret = 0 ;
ret += merge(l, mid);
ret += merge(mid + 1 , r);
int i = l, j = mid + 1 ;
int cnt = 0 ;
while(i <= mid && j <= r)
{
if (b[i] <= b[j]) c[++cnt] = b[i++];
else {
ret += mid - i + 1 ;
c[++cnt] = b[j++];
}
}
while (i <= mid) c[++cnt] = b[i++];
while (j <= r) c[++cnt] = b[j++];
for (int k = 1 , ll = l; k <= cnt; k++, ll++) b[ll] = c[k];
return ret;
}
```

#### 区间最大值

```
#include <iostream>
#define int long long
#define endl '\n'
using namespace std;
const int N = 2e5 + 10 , M = 18 ;
int a[N];
int f[N][M];
int log[N];
int n, m;
void init() {
for (int i = 2 ; i < N; i++) {
log[i] = log[i >> 1 ] + 1 ;
}
for (int j = 0 ; j < M; j++) {
for (int i = 1 ; i + ( 1 << j)- 1 <= n; i++) {
if (!j)
f[i][j] = a[i];
else {
f[i][j] = max(f[i][j - 1 ], f[i + ( 1 << (j - 1 ))][j - 1 ]);
}
```

## 区间合并

#### }

#### }

#### }

```
int query(int l, int r) {
int len = r - l + 1 ;
int k = log[len];
return max(f[l][k], f[r - ( 1 << k) + 1 ][k]);
}
void solve() {
cin >> n;
for (int i = 1 ; i <= n; i++) {
cin >> a[i];
}
init();
cin >> m;
while (m--) {
int a, b;
cin >> a >> b;
cout << query(a, b) << endl;
}
}
signed main() {
ios::sync_with_stdio(false);
cin.tie( 0 );
cout.tie( 0 );
solve();
}
void merge(vector<PII> &segs) {
vector<PII> res;
sort(segs.begin(), segs.end());
int st = - 2e9, ed = - 2e9;
for (auto seg : segs)
if (ed < seg.first) {
if (st != - 2e9)
res.push_back({st, ed});
st = seg.first, ed = seg.second;
} else
ed = max(ed, seg.second);
if (st != - 2e9)
res.push_back({st, ed});
segs = res;
}
int main() {
int n;
scanf("%d", &n);
vector<PII> segs;
for (int i = 0 ; i < n; i ++ ) {
int l, r;
scanf("%d%d", &l, &r);
```

## Oeis

```
segs.push_back({l, r});
}
merge(segs);
cout << segs.size() << endl;
return 0 ;
}
第一行一个正整数T( 1 \leq T \leq 10 ^2)T( 1 ≤T≤
2
)，表示有T组样例
对于每组样例，第一行一个正整数maxn( 20 \leq maxn \leq 50 )maxn( 20 ≤maxn≤50)。
输入数据保证maxn远大于最简递推式的阶数（如果存在的话）。
接下来一行maxn个整数，表示暴力程序跑出的答案(- 10 ^{ 18 } \leq a[i] \leq 10 ^{ 18 })(−
18
≤a[i]≤
18
)。
#include<bits/stdc++.h>
#define N 205
using namespace std;
const double eps=1e- 8 ;
int number;
int T,ans;
double a[N][N],del;
long long arr[N],ki[ 30 ];
bool flag;
bool gauss(int n)
{
for(int i= 1 ;i<=n;i++)
{
int k=i;
for(int j=i+ 1 ;j<=n;j++)if(fabs(a[j][i])>fabs(a[k][i]))k=j;
if(fabs(del=a[k][i])<eps)return 0 ;
for(int j=i;j<=n+ 1 ;j++)swap(a[i][j],a[k][j]);
for(int j=i;j<=n+ 1 ;j++)a[i][j]/=del;
for(k= 1 ;k<=n;k++)if(k!=i)
{
del=a[k][i];
for(int j=i;j<=n+ 1 ;j++)a[k][j]-=a[i][j]*del;
}
}
return 1 ;
}
void work(long long k)
{
memset(a, 0 ,sizeof(a));
for(long long i= 1 ;i<=k+ 4 ;++i)
{
for(long long j= 1 ;j<=k;++j)
{
a[i][j]=arr[i+j- 1 ];
}
```

a[i][k+ 1 ]= 1 ;
a[i][k+ 2 ]=(i+k);
a[i][k+ 3 ]=(i+k)*(i+k);
a[i][k+ 4 ]=(i+k)*(i+k)*(i+k);
a[i][k+ 5 ]=arr[i+k];
}
if(gauss(k+ 4 ))
{
memset(ki, 0 ,sizeof(ki));
for(int i= 1 ;i<=k+ 4 ;++i)
{
ki[i]=round(a[i][k+ 5 ]);
}
for(int i= 1 ;i<=k/ 2 ;++i)
{
swap(ki[i],ki[k-i+ 1 ]);
}
for(long long i=k+ 1 ;i<=number;++i)
{
long long sum= 0 ;
for(int j= 1 ;j<=k;++j)
{
sum+=arr[i-j]*ki[j];
}
sum+=ki[k+ 1 ];
sum+=ki[k+ 2 ]*i;
sum+=ki[k+ 3 ]*i*i;
sum+=ki[k+ 4 ]*i*i*i;
if(arr[i]!=sum)return;
}
flag=true;
return;
}
}
int main()
{
scanf("%d",&T);
while(T--)
{
scanf("%d",&number);
for(int i= 1 ;i<=number;++i)
{
scanf("%lld",&arr[i]);
}
flag=false;
for(int i= 0 ;i<= 5 ;++i)
{
work(i);
if(flag)
{
ans=i;
break;
}
}
if(flag)
{
if(ans)
{

printf("a[1]=%d",arr[ 1 ]);
}
for(int i= 2 ;i<=ans;++i)
{
printf(",a[%d]=%d",i,arr[i]);
}
if(ans)printf("\n");
printf("a[i]=");
bool fi=true;
for(int i= 1 ;i<=ans;++i)
{
if(ki[i])
{
if(ki[i]> 0 )
{
if(!fi)printf("+");
}
else
{
printf("-");
}
if(abs(ki[i])!= 1 )
{
printf("%lld*a[i-%d]",abs(ki[i]),i);
}
else
{
printf("a[i-%d]",i);
}
fi=false;
}
}
if(ki[ans+ 4 ])
{
if(ki[ans+ 4 ]> 0 )
{
if(!fi)printf("+");
}
else
{
printf("-");
}
if(abs(ki[ans+ 4 ])!= 1 )
{
printf("%lld*i*i*i",abs(ki[ans+ 4 ]));
}
else
{
printf("i*i*i");
}
fi=false;
}
if(ki[ans+ 3 ])
{
if(ki[ans+ 3 ]> 0 )
{
if(!fi)printf("+");
}

else
{
printf("-");
}
if(abs(ki[ans+ 3 ])!= 1 )
{
printf("%lld*i*i",abs(ki[ans+ 3 ]));
}
else
{
printf("i*i");
}
fi=false;
}
if(ki[ans+ 2 ])
{
if(ki[ans+ 2 ]> 0 )
{
if(!fi)printf("+");
}
else
{
printf("-");
}
if(abs(ki[ans+ 2 ])!= 1 )
{
printf("%lld*i",abs(ki[ans+ 2 ]));
}
else
{
printf("i");
}
fi=false;
}
if(ki[ans+ 1 ])
{
if(ki[ans+ 1 ]> 0 )
{
if(!fi)printf("+");
}
else
{
printf("-");
}
printf("%lld",abs(ki[ans+ 1 ]));
fi=false;
}
if(fi)printf("0");
printf("\n");
}
else
{
printf("No_solution\n");
}
}
return 0 ;
}
/*

# 图论

## dijkstra

```
scanf("%d",&n);
for(int i=1;i<=n;i++)
for(int j=1;j<=n+1;j++)scanf("%lf",&a[i][j]);
bool flag=gauss();
if(!flag)puts("No Solution");
else for(int i=1;i<=n;i++)printf("%.2lf\n",a[i][n+1]);
*/
int dijkstra()
{
priority_queue<PII,vector<PII>,greater<PII>> heap;
memset(dist,0x3f,sizeof dist);
heap.push({ 0 , 1 });
dist[ 1 ]= 0
while(heap.size())
{
auto t = heap.top();
heap.pop();
int ver = t.y,distance = t.x;
//cout << ver << endl;
if(st[ver])  continue;
st[ver] = true;
for(int i = h[ver]; ~i; i = ne[i])
{
int j = e[i];
if(dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j],j});
}
}
}
int res = - 0x3f3f3f3f;
for(int i = 1 ; i <= n; i ++)
{
if(dist[i]==0x3f3f3f3f) return - 1 ;
res = max(res,dist[i]);
}
return res;
}
void dijstra() {
memset(st, false, sizeof st);
memset(dist, 0x3f, sizeof dist);
dist[ 1 ] = 0 ;
```

## SPFA

```
for (int i = 0 ; i < n - 1 ; i++) {
int t = - 1 ;
for (int j = 1 ; j <= n; j++) {
if (!st[j] && (t == - 1 || dist[t] > dist[j])) {
t = j;
}
}
for (int j = 0 ; j < g[t].size(); j++) {
int aim = g[t][j].first;
int dis = g[t][j].second;
dist[aim] = min(dist[aim], dist[t] + dis);
}
st[t] = true;
}
}
void add(int a, int b, int c){
e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}
int spfa(){
memset(dist, 0x3f, sizeof dist);
dist[ 1 ] = 0 ;
queue<int> q;
q.push( 1 );
st[ 1 ] = true;
while (q.size()){
int t = q.front();
q.pop();
st[t] = false;
for (int i = h[t]; i != - 1 ; i = ne[i]){
int j = e[i];
if (dist[j] > dist[t] + w[i]){
dist[j] = dist[t] + w[i];
if (!st[j]){
q.push(j);
st[j] = true;
}
}
}
}
return dist[n];
}
```

#### //负环

```
void add(int a, int b, int c)
{
e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}
bool spfa()
{
```

## 拓扑排序

```
queue<int> q;
for (int i = 1 ; i <= n; i ++ )
{
st[i] = true;
q.push(i);
}
while (q.size())
{
int t = q.front();
q.pop();
st[t] = false;
for (int i = h[t]; i != - 1 ; i = ne[i])
{
int j = e[i];
if (dist[j] > dist[t] + w[i])
{
dist[j] = dist[t] + w[i];
cnt[j] = cnt[t] + 1 ;
if (cnt[j] >= n) return true;
if (!st[j])
{
q.push(j);
st[j] = true;
}
}
}
}
return false;
}
#include<iostream>
#include<cstring>
using namespace std;
const int N= 1010 ;
int f[N][N];
int v[N],w[N];
int n,m;
int main(){
cin>>n>>m;
for(int i= 1 ;i<=n;i++)cin>>v[i]>>w[i];
for(int i=n;i>= 1 ;i--){
for(int j= 0 ;j<=m;j++){
f[i][j]=f[i+ 1 ][j];
if(j>=v[i]){
f[i][j]=max(f[i][j],f[i+ 1 ][j-v[i]]+w[i]);
}
}
}
```

## 有向图强连通分量

```
int j=m;
for(int i= 1 ;i<=n;i++){
if(j>=v[i]&&f[i][j]==f[i+ 1 ][j-v[i]]+w[i]){
cout<<i<<" ";
j-=v[i];
}
}
return 0 ;
}
```

#### 每一头牛的愿望就是变成一头最受欢迎的牛。

#### 现在有 N 头牛，编号从 1 到 N，给你 M 对整数 (A,B)，表示牛 A 认为牛 B 受欢迎。

#### 这种关系是具有传递性的，如果 A 认为 B 受欢迎，B 认为 C 受欢迎，那么牛 A 也认为牛 C 受欢迎。

#### 你的任务是求出有多少头牛被除自己之外的所有牛认为是受欢迎的。

```
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N= 10010 ,M= 50010 ;
int n,m;
int h[N],e[M],ne[M],idx;
int dfn[N];//时间戳
int low[N];//从n点开始遍历，能遍历到的时间戳最小的点
int timestamp;
int stk[N],top;
//当前还没搜索完的强连通分量的所有点
bool in_stk[N];
int id[N];//某个点属于哪个强连通分量
int scc_cnt;//强连通分量的数量
int Size[N];//记录强连通分量中点的数量
int dout[N];//每个强连通分量的出度
void add(int a,int b){
e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
void tarjan(int u){
dfn[u]=low[u]=++timestamp;
stk[++top]=u,in_stk[u]=true;
for(int i=h[u];~i;i=ne[i]){
int j=e[i];
if(!dfn[j]){
tarjan(j);
low[u]=min(low[u],low[j]);
}else if(in_stk[j]){
low[u]=min(low[u],dfn[j]);
}
}
```

## LCA

```
if(dfn[u]==low[u]){
int y;
++scc_cnt;
do{
y=stk[top--];
in_stk[y]=false;
id[y]=scc_cnt;
Size[scc_cnt]++;
}while(y!=u);
}
}
int main(){
cin>>n>>m;
memset(h,- 1 ,sizeof h);
while(m--){
int a,b;
cin>>a>>b;
add(a,b);
}
for(int i= 1 ;i<=n;i++){
if(!dfn[i]){
tarjan(i);
}
}
for(int i= 1 ;i<=n;i++){
for(int j=h[i];~j;j=ne[j]){
int k=e[j];
int a=id[i],b=id[k];
if(a!=b){
dout[a]++;
}
}
}
int zeros= 0 ,sum= 0 ;
for(int i= 1 ;i<=scc_cnt;i++){
if(!dout[i]){
zeros++;
sum+=Size[i];
if(zeros> 1 ){
sum= 0 ;
break;
}
}
}
cout<<sum<<endl;
}
```

#### 问询距离

\#include <bits/stdc++.h>
\#define int long long
\#define endl '\n'
using namespace std;
const int N = 1e4 + 10 ;

int n, m;
int dep[N];
int d[N][ 20 ];
typedef pair<int, int> PII;
vectorg[N];
int fa[N][ 20 ];
bool st[N];
void bfs() {
dep[ 1 ] = 1 ;
queueq;
q.push( 1 );
while (q.size()) {
int t = q.front();
q.pop();
if (st[t])
continue;
st[t] = true;
for (auto i : g[t]) {
if (st[i.first])
continue;
dep[i.first] = dep[t] + 1 ;
q.push(i.first);
fa[i.first][ 0 ] = t;
d[i.first][ 0 ] = i.second;
for (int k = 1 ; k <= 15 ; k++) {
fa[i.first][k] = fa[fa[i.first][k - 1 ]][k - 1 ];
d[i.first][k] = d[i.first][k - 1 ] + d[fa[i.first][k - 1 ]][k -
1 ];
}
}
}
}

int lca(int a, int b) {
int res = 0 ;
if (dep[a] < dep[b])
swap(a, b);
for (int i = 16 ; i >= 0 ; i--) {
if (dep[fa[a][i]] >= dep[b]) {
res += d[a][i];
a = fa[a][i];
}
}
/*
for(int i = 16; i >= 0; i --)
if(dep[fa[a][i]] >= dep[b])
{
res += d[a][i];
a = fa[a][i];
}

*/

## 差分约束

```
if (a == b) {
return res;
}
for (int k = 15 ; k >= 0 ; k--) {
if (fa[a][k] != fa[b][k]) {
res += d[a][k] + d[b][k];
a = fa[a][k];
b = fa[b][k];
}
}
res += d[a][ 0 ] + d[b][ 0 ];
return res;
}
void solve() {
cin >> n >> m;
for (int i = 1 ; i < n; i++) {
int a, b, c;
cin >> a >> b >> c;
g[a].push_back({b, c});
g[b].push_back({a, c});
}
bfs();
while (m--) {
int x, y;
cin >> x >> y;
cout << lca(x, y) << endl;
}
}
signed main() {
ios::sync_with_stdio(false);
cin.tie( 0 );
cout.tie( 0 );
//int t;
//cin >> t;
//while (t--)
solve();
}
```

#### 幼儿园里有 N 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。

#### 但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果

#### 的时候， 老师需要满足小朋友们的 K 个要求。

#### 幼儿园的糖果总是有限的，老师想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并

#### 且满足小朋友们所有的要求。

#### 输入格式

#### 输入的第一行是两个整数 N,K。

#### 接下来 K 行，表示分配糖果时需要满足的关系，每行 3 个数字 X,A,B。

#### 如果 X= 1 ．表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的糖果一样多。

#### 如果 X= 2 ，表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果。

#### 如果 X= 3 ，表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果。

#### 如果 X= 4 ，表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果。

#### 如果 X= 5 ，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。

#### 小朋友编号从 1 到 N。

\#pragma GCC optimize(2)
\#include <bits/stdc++.h>
\#define endl '\n'
\#define int long long
using namespace std;
const int N = 100010 , M = 300010 ;
int h[N], e[M], w[M], ne[M], idx;
int n, m;
int dist[N];
int q[N], cnt[N]; //cnt:用来求正环
bool st[N];

void add(int a, int b, int c) {
e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

bool spfa() { //求最长路
int hh = 0 , tt = 1 ;
memset(dist, -0x3f, sizeof dist);
dist[ 0 ] = 0 ;
q[ 0 ] = 0 ;
st[ 0 ] = true;
while (hh != tt) {
int t = q[ -- tt];
st[t] = false;
for (int i = h[t]; ~i; i = ne[i]) {
int j = e[i];
if (dist[j] < dist[t] + w[i]) {
dist[j] = dist[t] + w[i];
cnt[j] = cnt[t] + 1 ;
if (cnt[j] >= n + 1 )
return false;
if (!st[j]) {
q[tt ++ ] = j;
st[j] = true;
}
}
}
}
return true;

}

void solve() {
scanf("%lld%lld", &n, &m);
memset(h, - 1 , sizeof h);
while (m--) {
int x, a, b;
scanf("%lld%lld%lld", &x, &a, &b);
if (x == 1 ) {

## 负环

```
add(b, a, 0 ), add(a, b, 0 );
} else if (x == 2 ) {
add(a, b, 1 );
} else if (x == 3 ) {
add(b, a, 0 );
} else if (x == 4 ) {
add(b, a, 1 );
} else {
add(a, b, 0 );
}
}
for (int i = 1 ; i <= n; i++) {
add( 0 , i, 1 );
}
if (!spfa()) { //有环
puts("-1");
} else {
int res = 0 ;
for (int i = 1 ; i <= n; i++)
res += dist[i];
printf("%lld\n", res);
}
return;
}
signed main() {
solve();
}
```

#### 农夫约翰在巡视他的众多农场时，发现了很多令人惊叹的虫洞。

#### 虫洞非常奇特，它可以看作是一条 单向 路径，通过它可以使你回到过去的某个时刻（相对于你进入虫洞之

#### 前）。

#### 农夫约翰的每个农场中包含 N 片田地，M 条路径（双向）以及 W 个虫洞。

#### 现在农夫约翰希望能够从农场中的某片田地出发，经过一些路径和虫洞回到过去，并在他的出发时刻之前赶到

#### 他的出发地。

#### 他希望能够看到出发之前的自己。

#### 请你判断一下约翰能否做到这一点。

#### 下面我们将给你提供约翰拥有的农场数量 F，以及每个农场的完整信息。

#### 已知走过任何一条路径所花费的时间都不超过 10000 秒，任何虫洞将他带回的时间都不会超过 10000 秒。

#### 输入格式

#### 第一行包含整数 F，表示约翰共有 F 个农场。

#### 对于每个农场，第一行包含三个整数 N,M,W。

#### 接下来 M 行，每行包含三个整数 S,E,T，表示田地 S 和 E 之间存在一条路径，经过这条路径所花的时间

#### 为 T。

#### 再接下来 W 行，每行包含三个整数 S,E,T，表示存在一条从田地 S 走到田地 E 的虫洞，走过这条虫洞，

#### 可以回到 T 秒之间。

\#include
\#include
\#include
using namespace std;
const int N= 510 ,M= 6000 ;
int h[N],e[M],ne[M],w[M],idx;
int cnt[N],dist[N],q[N];
bool st[N];
int n,m1,m2;
void add(int a,int b,int c){
e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;
}
bool spfa(){
int hh= 0 ,tt= 0 ;
memset(st,false,sizeof st);
memset(dist, 0 ,sizeof dist);
memset(cnt, 0 ,sizeof cnt);
for(int i= 1 ;i<=n;i++){
q[tt++]=i;
st[i]=true;
}
while(hh!=tt){
int t=q[hh++];
st[t]=false;
if(hh==N)hh= 0 ;
for(int i=h[t];~i;i=ne[i]){
int j=e[i];
if(dist[j]>dist[t]+w[i]){
dist[j]=dist[t]+w[i];
cnt[j]=cnt[t]+ 1 ;
if(cnt[j]>=n)return true;
if(!st[j]){
st[j]=true;
q[tt++]=j;
if(tt==N)tt= 0 ;
}
}
}
}
return false;
}
int main(){
int t;
cin>>t;
while(t--){
cin>>n>>m1>>m2;
memset(h,- 1 ,sizeof h);
idx= 0 ;
while(m1--){
int a,b,c;
cin>>a>>b>>c;
add(a,b,c),add(b,a,c);
}

## kruskal

## 匈牙利

```
while(m2--){
int a,b,c;
cin>>a>>b>>c;
add(a,b,-c);
}
if(spfa()){
cout<<"YES"<<endl;
}else {
cout<<"NO"<<endl;
}
}
}
struct Edge{
int a, b, w;
bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];
int find(int x){
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
int kruskal(){
sort(edges, edges + m);
for (int i = 1 ; i <= n; i ++ ) p[i] = i;  // 初始化并查集
int res = 0 , cnt = 0 ;
for (int i = 0 ; i < m; i ++ ){
int a = edges[i].a, b = edges[i].b, w = edges[i].w;
a = find(a), b = find(b);
if (a != b){
p[a] = b;
res += w;
cnt ++ ;
}
}
if (cnt < n - 1 ) return INF;
return res;
}
bool find(int x)
{
for(int i= 0 ;i<g[x].size();i++)
{
int a=g[x][i];
```

## 最大权值匹配(匈牙利,KM算法)

```
if(!st[a])
{
st[a]=true;
if(ma[a]== 0 ||find(ma[a]))
{
ma[a]=x;
return true;
}
}
}
return false;
}
int main()
{
cin>>n1>>n2>>m;
while(m--)
{
int a,b;
scanf("%d%d",&a,&b);
g[a].push_back(b);
}
int ans= 0 ;
for(int i= 1 ;i<=n1;i++)
{
memset(st,false,sizeof st);
if(find(i))ans++;
}
cout<<ans<<endl;
}
#pragma GCC optmize(2)
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
typedef long long ll;
typedef unsigned long long ull;//卡精度
typedef pair<int, int> PII;
const int N = 607 , M = 5e3 + 7 , maxn = 1007 ;
const int mod = 1e9 + 7 ;
const ll INF = 1e15 + 7 ;
ll w[N][N];//边权
ll la[N], lb[N];//左、右部点的顶标
bool va[N], vb[N];//访问标记，是否在交错树中
int match[N];//右部点匹配的左部点（一个只能匹配一个嘛）
int n;
ll delta, upd[N];
int p[N];
ll c[N];
void bfs(int x) {
int a, y = 0 , y1 = 0 ;
```

for (int i = 1 ; i <= n; ++ i)
p[i] = 0 , c[i] = INF;
match[y] = x;
do {
a = match[y], delta = INF, vb[y] = true;
for (int b = 1 ; b <= n; ++ b) {
if (!vb[b]) {
if (c[b] > la[a] + lb[b] - w[a][b])
c[b] = la[a] + lb[b] - w[a][b], p[b] = y;
if (c[b] < delta) //Δ还是取最小的
delta = c[b], y1 = b;
}
}
for (int b = 0 ; b <= n; ++ b)
if (vb[b])
la[match[b]] -= delta, lb[b] += delta;
else
c[b] -= delta;
y = y1;
} while (match[y]);
while (y)
match[y] = match[p[y]], y = p[y];
}
ll KM() {
for (int i = 1 ; i <= n; ++ i)
match[i] = la[i] = lb[i] = 0 ;
for (int i = 1 ; i <= n; ++ i) {
for (int j = 1 ; j <= n; ++ j)
vb[j] = false;
bfs(i);
}
ll res = 0 ;
for (int y = 1 ; y <= n; ++ y)
res += w[match[y]][y];
return res;
}

ll A[N], B[N], C[N], P[N];

int main() {
scanf("%d", &n);
for (int i = 1 ; i <= n; ++ i)
scanf("%lld", &A[i]);
for (int i = 1 ; i <= n; ++ i)
scanf("%lld", &P[i]);
for (int i = 1 ; i <= n; ++ i)
scanf("%lld", &B[i]);
for (int i = 1 ; i <= n; ++ i)
scanf("%lld", &C[i]);
for (int i = 1 ; i <= n; ++ i)
for (int j = 1 ; j <= n; ++ j) {
ll sum = 0 ;
for (int k = 1 ; k <= n; ++ k) {
if (A[k] < B[i] + C[j])
sum += P[k];
}
w[i][j] = sum;
}

## dinic

```
printf("%lld\n", KM());
return 0 ;
}
const int N = 10010 , M = 200010 , inf = 1e8;
int n, m, S, T;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
void add(int a, int b, int c) {
e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
e[idx] = a, f[idx] = 0 , ne[idx] = h[b], h[b] = idx ++ ;
}
bool bfs() {
int hh = 0 , tt = 0 ;
memset(d, - 1 , sizeof d);
q[ 0 ] = S, d[S] = 0 , cur[S] = h[S];
while (hh <= tt) {
int t = q[hh ++ ];
for (int i = h[t]; ~i; i = ne[i]) {
int ver = e[i];
if (d[ver] == - 1 && f[i]) {
d[ver] = d[t] + 1 ;//ver是t的下一级，防止回流
cur[ver] = h[ver];
if (ver == T)
return true;
q[ ++ tt] = ver;
}
}
}
return false;
}
int find(int u, int limit) {
if (u == T)
return limit;//到了最终点，不用考虑后面的，上限就是可扩展的量
int flow = 0 ;
for (int i = cur[u]; ~i && flow < limit; i = ne[i]) {
cur[u] = i; //当前弧优化
int ver = e[i];
if (d[ver] == d[u] + 1 && f[i]) {
int t = find(ver, min(f[i], limit - flow)); //下一条流量的最小值
//或者当前流量限制减去这条路已经花掉的流量中的最小值
if (!t)
d[ver] = - 1 ; //遍历过了
f[i] -= t;
f[i ^ 1 ] += t;
flow += t;
}
}
return flow;//返回可拓展流量
}
int dinic() {
int r = 0 , flow;
```

# 动态规划

## 数位DP

```
while (bfs())//用bfs划分阶级
while (flow = find(S, inf))//不断用dfs进行扩展
r += flow;
return r;
}
int main() {
cin >> n >> m >> S >> T;
memset(h, - 1 , sizeof h);
while (m--) {
int a, b, c;
cin >> a >> b >> c;
add(a, b, c);
}
cout << dinic() << endl;
}
现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。
#pragma GCC optmize(2)
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N = 50 ;
int a[N];
int f[N][ 12 ];
int dp(int pos, int pre, int op) {
if (pos == 0 )
return 1 ;
if (!op && ~f[pos][pre])
return f[pos][pre];
int res = 0 , maxn = op? a[pos] : 9 ;
for (int i = pre; i <= maxn; i++) {
res += dp(pos - 1 , i, op && (i == a[pos]));
}
return op? res : f[pos][pre] = res;
}
int calc(int x) {
memset(f, - 1 , sizeof f);
int cnt = 0 ;
while (x) {
a[++cnt] = x % 10 ;
x /= 10 ;
}
return dp(cnt, 0 , 1 );
}
```

void solve() {
int l, r;
while (cin >> l >> r) {
cout << calc(r) - calc(l - 1 ) << endl;
}

}

signed main() {
ios::sync_with_stdio(false);
cin.tie( 0 );
cout.tie( 0 );

solve();
}

Windy 定义了一种 Windy 数：不含前导零且相邻两个数字之差至少为 2 的正整数被称为 Windy 数。

Windy 想知道，在 A 和 B 之间，包括 A 和 B，总共有多少个 Windy 数？
\#include <bits/stdc++.h>
\#define int long long
\#define endl '\n'
using namespace std;
const int N = 35 ;
int a[N];
int f[N][N];

bool check(int x) {

if (x == 1 )
return false;
if (x == 2 )
return true;
int k = sqrt(x);
for (int i = 2 ; i <= k; i++) {
if (x % i == 0 )
return false;
}
return true;
}

int dp(int pos, int st, int op, int pre) {
if (!pos)
return 1 ;
if (!op && ~f[pos][st])
return f[pos][st];

int res = 0 , maxn = op? a[pos] : 9 ;
for (int i = 0 ; i <= maxn; i++) {
if (abs(i - st) >= 2 && i >= 0 ) {
if (i == 0 && pre){
//第一位空缺
res += dp(pos - 1 , - 5 , op && i == a[pos], pre);
}
else
res += dp(pos - 1 , i, op && i == a[pos], 0 );
}

## 二进制优化多重背包DP

#### }

```
return op? res : f[pos][st] = res;
}
int calc(int x) {
memset(f, - 1 , sizeof f);
int cnt = 0 ;
while (x) {
a[++cnt] = x % 10 ;
x /= 10 ;
}
return dp(cnt, - 5 , 1 , 1 );
}
void solve() {
int a, b;
cin >> a >> b;
cout << calc(b) - calc(a - 1 ) << endl;
```

#### }

```
signed main() {
ios::sync_with_stdio(false);
cin.tie( 0 );
cout.tie( 0 );
solve();
}
```

#### 有 N 种物品和一个容量是 V 的背包。

```
第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
int n, m;
const int N = 2010 ;
int f[N];
struct node {
int v, w;
};
void solve() {
cin >> n >> m;
vector<node>goods;
for (int i = 0 ; i < n; i++) {
int v, w, s;
cin >> v >> w >> s; //把一组货物分成很多份
```

## 背包求方案

```
for (int k = 1 ; k <= s; k *= 2 ) {
s -= k;
goods.push_back({v * k, w * k});
}
if (s) {
goods.push_back({v * s, w * s});
}
}
//01背包
for (auto good : goods) {
for (int j = m; j >= good.v; j--) {
f[j] = max(f[j], f[j - good.v] + good.w);
}
}
cout << f[m] << endl;
```

#### }

```
signed main() {
ios::sync_with_stdio(false);
cin.tie( 0 );
cout.tie( 0 );
solve();
}
```

#### 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

```
第 i 件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1 ...N。
#include<iostream>
#include<cstring>
using namespace std;
const int N= 1010 ;
int f[N][N];
int v[N],w[N];
int n,m;
int main(){
cin>>n>>m;
for(int i= 1 ;i<=n;i++)cin>>v[i]>>w[i];
for(int i=n;i>= 1 ;i--){
for(int j= 0 ;j<=m;j++){
f[i][j]=f[i+ 1 ][j];
if(j>=v[i]){
f[i][j]=max(f[i][j],f[i+ 1 ][j-v[i]]+w[i]);
}
}
}
int j=m;
for(int i= 1 ;i<=n;i++){
```

# 数据结构

## 线段树

```
if(j>=v[i]&&f[i][j]==f[i+ 1 ][j-v[i]]+w[i]){
cout<<i<<" ";
j-=v[i];
}
}
return 0 ;
}
const int N = 200010 ;
int m, p;
struct node {
int l, r;
int v;
} tr[ 4 * N];
void pushup(int u) {
tr[u].v = max(tr[u << 1 ].v, tr[u << 1 | 1 ].v);
}
void build(int u, int l, int r) {
tr[u] = {l, r};
if (l == r)
return;
int mid = l + r >> 1 ;
build(u << 1 , l, mid), build(u << 1 | 1 , mid + 1 , r);
}
int query(int u, int l, int r) {
if (tr[u].l >= l && tr[u].r <= r) {
return tr[u].v;
} int mid = tr[u].l + tr[u].r >> 1 ;
int v = 0 ;
if (l <= mid) v = query(u << 1 , l, r);
if (r > mid) v = max(v, query(u << 1 | 1 , l, r));
return v;
}
void modify(int u, int x, int v) {
if (tr[u].l == x && tr[u].r == x) {
tr[u].v = v;
} else {
int mid = tr[u].l + tr[u].r >> 1 ;
if (x <= mid)
modify(u << 1 , x, v);
else
modify(u << 1 | 1 , x, v);
pushup(u);
}
}
```

int main() {
int n = 0 , last = 0 ;
char ch;
int x;
cin >> m >> p;
build( 1 , 1 , m);
while (m--) {
cin >> ch >> x;
if (ch == 'Q') {
last = query( 1 , n - x + 1 , n);
cout << last << endl;
} else {
modify( 1 , n + 1 , (last + x) % p);
n++;
}
}
}

\#include
using namespace std;
const int N = 100010 ;
typedef long long ll;
int n, m, w[N];

struct node {
int l, r;
ll sum, add;
} tr[ 4 * N];

void pushup(int u) {
tr[u].sum = tr[u << 1 ].sum + tr[u << 1 | 1 ].sum;
}

void pushdown(int u) {
auto &root = tr[u], &left = tr[u << 1 ], &right = tr[u << 1 | 1 ];
if (root.add) {
left.add += root.add;
left.sum += (ll)(left.r - left.l + 1 ) * root.add;
right.add += root.add;
right.sum += (ll)(right.r - right.l + 1 ) * root.add;
root.add = 0 ;
}
}

void build(int u, int l, int r) {
if (l == r) {
tr[u] = {l, r, w[r], 0 };
} else {
tr[u] = {l, r};
int mid = l + r >> 1 ;
build(u << 1 , l, mid), build(u << 1 | 1 , mid + 1 , r);
pushup(u);
}
}

## 主席树

```
void modify(int u, int l, int r, int d) {
if (tr[u].l >= l && tr[u].r <= r) {
tr[u].sum += (ll)(tr[u].r - tr[u].l + 1 ) * d;
tr[u].add += d;
} else {
pushdown(u);
int mid = tr[u].l + tr[u].r >> 1 ;
if (l <= mid)
modify(u << 1 , l, r, d);
if (r > mid)
modify(u << 1 | 1 , l, r, d);
pushup(u);
}
}
ll query(int u, int l, int r) {
if (tr[u].l >= l && tr[u].r <= r)
return tr[u].sum;
pushdown(u);
int mid = tr[u].l + tr[u].r >> 1 ;
ll sum = 0 ;
if (l <= mid)
sum = query(u << 1 , l, r);
if (r > mid)
sum += query(u << 1 | 1 , l, r);
return sum;
}
int main() {
cin >> n >> m;
for (int i = 1 ; i <= n; i++)
cin >> w[i];
build( 1 , 1 , n);
char ch;
int l, r, d;
while (m--) {
cin >> ch >> l >> r;
if (ch == 'C') {
cin >> d;
modify( 1 , l, r, d);
} else {
cout << query( 1 , l, r) << endl;
}
}
}
```

#### 给定长度为 N 的整数序列 A，下标为 1 ∼N。

```
现在要执行 M 次操作，其中第 i 次操作为给出三个整数 li,ri,ki，求 A[li],A[li+ 1 ],...,A[ri] (即
A 的下标区间 [li,ri])中第 ki 小的数是多少。
using namespace std;
const int N = 100010 ;
const int M = 10010 ;
int n, m;
```

int a[N];

vectornums;//离散化
struct node {
int l, r; //表示左右儿子
int cnt;//区间中数的个数
} tr[N * 4 + N * 17 ];

int root[N];//每个版本的节点
int idx;//当前的下标
int find(int x) { //找每个数离散化的值是多少
return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
}

int build(int l, int r) {
int p = ++idx;
if (l == r)
return p;
int mid = l + r >> 1 ;
tr[p].l = build(l, mid), tr[p].r = build(mid + 1 , r);
return p;
}

int insert(int p, int l, int r, int x) { //原来的根节点 左右边界 插入的位置
int q = ++idx;
tr[q] = tr[p];
if (l == r) {
tr[q].cnt++;
return q;
}
int mid = l + r >> 1 ;
if (x <= mid)
tr[q].l = insert(tr[p].l, l, mid, x);
else
tr[q].r = insert(tr[p].r, mid + 1 , r, x);
tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;
return q;
}

int query(int q, int p, int l, int r, int k) {
if (l == r)
return r;
int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
int mid = l + r >> 1 ;
if (k <= cnt)
return query(tr[q].l, tr[p].l, l, mid, k);
else
return query(tr[q].r, tr[p].r, mid + 1 , r, k - cnt);
}

int main() {
cin >> n >> m;
for (int i = 1 ; i <= n; i++) {
cin >> a[i];
nums.push_back(a[i]);
}
sort(nums.begin(), nums.end());
nums.erase(unique(nums.begin(), nums.end()), nums.end());

## 数状数组

## trie

```
root[ 0 ] = build( 0 , nums.size() - 1 );
for (int i = 1 ; i <= n; i++) {
root[i] = insert(root[i - 1 ], 0 , nums.size() - 1 , find(a[i]));
}
while (m--) {
int l, r, k;
cin >> l >> r >> k;
cout << nums[query(root[r], root[l - 1 ], 0 , nums.size() - 1 , k)] <<
endl;
}
}
```

#### 注意不要有 0

```
int lowbit(int x)
{
return x & - x;
}
void add(int x , int c)//为第x个数加上c，这里为了表示是否出现，所以加的是 1
{
for(int i = x ; i <= n ; i += lowbit(i)) tr[i] += c;
}
//求1~x的和，tr[x]存储的是区间[x−lowbit(x)+1,x]出现的数的次数，题目说y1到yn是 1 到n的排列，
所以这个sum是用来求1~x中出现的数的个数
int sum(int x)
{
int res = 0 ;
for(int i = x ; i ; i -= lowbit(i))  res += tr[i];
return res;
}
const int N= 100010 ;
int cnt[N];
int f[N][ 26 ];
int idx;
void insert(char str[])
{
int p= 0 ;
for(int i= 0 ;str[i];i++)
{
int u=str[i]-'a';
if(!f[p][u])f[p][u]=++idx;
p=f[p][u];
}
cnt[p]++;
}
```

## trie（vector）

## splay

### 经过n次翻转，输出翻转后的结果

```
int que(char str[])
{
int p= 0 ;
for(int i= 0 ;str[i];i++)
{
int u=str[i]-'a';
if(!f[p][u])return 0 ;
p=f[p][u];
}
return cnt[p];
}
vector<array<int, 10 >> nex( 1 );//只支持数字字符串,如果是字母等需要修改
struct trie {
int ve[ 20000004 ];//储存字符串所对应的值
int cnt = 0 ;
//s是字符串，l是s的长度 num为对应值
void insert(string s, int l, int num) {
int p = 0 ;
for (int i = 0 ; i < l; i++) {
int c = s[i] - '0';
if (!nex[p][c])
nex.push_back({}), nex[p][c] = nex.size() - 1 ;
p = nex[p][c];
}
//代表他是否出现过
if (ve[p])
ve[p] = min(num, ve[p]);
else
ve[p] = num;
}
int find(string s, int l) {
int p = 0 ;
for (int i = 0 ; i < l; i++) {
int c = s[i] - '0';
if (!nex[p][c])
return 0 ;
p = nex[p][c];
}
return ve[p];
}
} tr;
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N= 100010 ;
int n,m;
```

struct node{
int s[ 2 ];//储存两个儿子
int p;//父节点
int v;//编号
int size;//子树大小
int flag;//有无翻转
int init(int _v,int _p){
v=_v,p=_p;
size= 1 ;
}
}tr[N];
int root;//根节点
int idx;// 动态分配的空间的指针
void pushup(int x){//向上传递
tr[x].size=tr[tr[x].s[ 0 ]].size+tr[tr[x].s[ 1 ]].size+ 1 ;//左儿子加右儿子加根节点
}
void pushdown(int x){
if(tr[x].flag){//如果x是需要翻转的
swap(tr[x].s[ 0 ],tr[x].s[ 1 ]);//翻转一下左右儿子
tr[tr[x].s[ 0 ]].flag^= 1 ;//向下传左右儿子的标记
tr[tr[x].s[ 1 ]].flag^= 1 ;
tr[x].flag= 0 ;
}

}

void rotate(int x){//旋转操作
int y=tr[x].p;//x的父节点
int z=tr[y].p;//y的父节点
int k=tr[y].s[ 1 ]==x;//用k判断x是y的左儿子还是右儿子
// k=0 x是y的左儿子 k=1 x是y的右儿子
tr[z].s[tr[z].s[ 1 ]==y]=x,tr[x].p=z;//将z的儿子变成x，把x的父节点变成z
//利用tr[z].s[1]==y就不需要判定是左旋还是右旋
//如果z的右儿子是y，那么右儿子就变成x，否者左儿子变成x
tr[y].s[k]=tr[x].s[k^1];//y的左儿子变成x的右儿子
tr[tr[x].s[k^1]].p=y;//x的右(左)儿子的父节点等于y
tr[x].s[k^1]=y;
//x的右(左)儿子变成y
tr[y].p=x;//y的父节点变成x
pushup(y),pushup(x);
}

void splay(int x,int k){
while(tr[x].p!=k){//只要x的父节点不是k
int y=tr[x].p,z=tr[y].p;
if(z!=k){
if((tr[y].s[ 1 ]==x)^(tr[z].s[ 1 ]==y)){//只要是折线关系(一个左一个右)
rotate(x);//转x
}else {//如果是直线关系
rotate(y);
}
}
rotate(x);//最后还需要转x(保证中序排列)
}
if(!k)root=x;//如果k是源,就把源点让给x
}

void output(int u){//每次想要访问其儿子，就要把根节点的懒标记往下传

## 树剖

```
pushdown(u);
if(tr[u].s[ 0 ])output(tr[u].s[ 0 ]);//有左儿子就先递归输出左儿子
if(tr[u].v>= 1 &&tr[u].v<=n)cout<<tr[u].v<<" ";//如果当前点不是哨兵就输出当前点
if(tr[u].s[ 1 ])output(tr[u].s[ 1 ]);//接下来递归右儿子
}
void insert(int v){
int u=root,p= 0 ;
while(u){//求x应该插到哪个点
p=u,u=tr[u].s[v>tr[u].v];//如果传参v是u的左儿子就会返回 0
}
u=++idx;//给u新分配一个点
if(p){//如果u有父节点,父节点就要更新儿子信息
tr[p].s[v>tr[p].v]=u;
}
tr[u].init(v,p);//初始化u
splay(u, 0 );
}
int get_k(int k){//找第k个数
int u=root;
while( 1 ){
pushdown(u);//把信息传下去
if(tr[tr[u].s[ 0 ]].size>=k)u=tr[u].s[ 0 ];//如果左子树的点数大于k，说明k在右边
else if(tr[tr[u].s[ 0 ]].size+ 1 ==k){//如果左子树点数恰好等等于k，说明正好在这个点
return u;
}else{
k-=tr[tr[u].s[ 0 ]].size+ 1 ,u=tr[u].s[ 1 ];//k减去左边这些点的数量，再到右子树
中去找
}
}
return - 1 ;
}
int main(){
cin>>n>>m;
for(int i= 0 ;i<=n+ 1 ;i++){//加两个哨兵
insert(i);
}
while(m--){
int l,r;
cin>>l>>r;//由于加了哨兵，下标要变
l=get_k(l),r=get_k(r+ 2 );
splay(l, 0 ),splay(r,l);//把左端点转到根，右端点转到根的下面
tr[tr[r].s[ 0 ]].flag^= 1 ;//把r的左子树整个翻转一遍
}
output(root);//输出中序遍历
return 0 ;
}
#include <iostream>
#include <cstring>
#include <algorithm>
```

using namespace std;

typedef long long LL;
const int N = 100010 , M = N * 2 ;

int n, m;
int w[N], h[N], e[M], ne[M], idx;
int id[N];//dfs序的编号
int nw[N];//dfs序中第i个点的编号
int cnt;
int dep[N];//点在树的深度
int sz[N]; //该点为根的子树的大小
int top[N];//某点所属重链的顶点
int fa[N];//某点的父节点
int son[N];//某点的重儿子节点
struct Tree
{
int l, r;
LL add, sum;//懒标记 该子树数之和
}tr[N * 4 ];

void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs1(int u, int father, int depth)//当前点 父节点 深度
{
dep[u] = depth, fa[u] = father, sz[u] = 1 ;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (j == father) continue;
dfs1(j, u, depth + 1 );
sz[u] += sz[j];//加上子节点树的大小
if (sz[son[u]] < sz[j]) son[u] = j;
//如果当前节点的储存的重儿子的体积小于j，就要改变重儿子
}
}

// 当前点 当前点所属重链的顶点
void dfs2(int u, int t)//建立dfs序,保证重儿子编号连续
{
id[u] = ++ cnt;//编号
nw[cnt] = w[u];//dfs序编号对应w中的值
top[u] = t;
if (!son[u]) return;//如果u点没有重儿子(或儿子)就返回
dfs2(son[u], t);//递归重儿子
for (int i = h[u]; ~i; i = ne[i])//遍历轻儿子
{
int j = e[i];
if (j == fa[u] || j == son[u]) continue;
dfs2(j, j);
}
}

void pushup(int u)

#### {

tr[u].sum = tr[u << 1 ].sum + tr[u << 1 | 1 ].sum;
}

void pushdown(int u)
{
auto &root = tr[u], &left = tr[u << 1 ], &right = tr[u << 1 | 1 ];
if (root.add)
{
left.add += root.add, left.sum += root.add * (left.r - left.l + 1 );
right.add += root.add, right.sum += root.add * (right.r - right.l + 1 );
root.add = 0 ;
}
}

void build(int u, int l, int r)
{
tr[u] = {l, r, 0 , nw[r]};//这里构建的是dfs序的线段树
if (l == r) return;
int mid = l + r >> 1 ;
build(u << 1 , l, mid), build(u << 1 | 1 , mid + 1 , r);
pushup(u);
}

void update(int u, int l, int r, int k)//给l到r上所有点
{
if (l <= tr[u].l && r >= tr[u].r)
{
tr[u].add += k;
tr[u].sum += k * (tr[u].r - tr[u].l + 1 );
return;
}
pushdown(u);
int mid = tr[u].l + tr[u].r >> 1 ;
if (l <= mid) update(u << 1 , l, r, k);
if (r > mid) update(u << 1 | 1 , l, r, k);
pushup(u);
}

LL query(int u, int l, int r)
{
if (l <= tr[u].l && r >= tr[u].r) return tr[u].sum;
pushdown(u);
int mid = tr[u].l + tr[u].r >> 1 ;
LL res = 0 ;
if (l <= mid) res += query(u << 1 , l, r);
if (r > mid) res += query(u << 1 | 1 , l, r);
return res;
}

void update_path(int u, int v, int k)
{
//优先走更低的那个点(离源更远)
while (top[u] != top[v])//如果两点不在同一重链
{
if (dep[top[u]] < dep[top[v]]) swap(u, v);//优先走链头离源远的那个点
update( 1 , id[top[u]], id[u], k);//在dfs先遍历到的是u点的链头
u = fa[top[u]];//将u跳到链头的父系节点

#### }

if (dep[u] < dep[v]) swap(u, v);
update( 1 , id[v], id[u], k);//最后再更新一次
}

LL query_path(int u, int v)//问询同理
{
LL res = 0 ;
while (top[u] != top[v])
{
if (dep[top[u]] < dep[top[v]]) swap(u, v);
res += query( 1 , id[top[u]], id[u]);
u = fa[top[u]];
}
if (dep[u] < dep[v]) swap(u, v);
res += query( 1 , id[v], id[u]);
return res;
}

void update_tree(int u, int k)//更新一个树
{
update( 1 , id[u], id[u] + sz[u] - 1 , k);
//每个子树的根节点是第一个被搜到的
//所以在线段树中是以该点开始，以该点加上体积-1结束
}

LL query_tree(int u)
{
return query( 1 , id[u], id[u] + sz[u] - 1 );//与update同理
}

int main()
{
scanf("%d", &n);
for (int i = 1 ; i <= n; i ++ ) scanf("%d", &w[i]);
memset(h, - 1 , sizeof h);
for (int i = 0 ; i < n - 1 ; i ++ )
{
int a, b;
scanf("%d%d", &a, &b);
add(a, b), add(b, a);
}
dfs1( 1 , - 1 , 1 );//计算每个点的重儿子
dfs2( 1 , 1 );//求dfs序
build( 1 , 1 , n);//建立线段树维护数据

scanf("%d", &m);
while (m -- )
{
int t, u, v, k;
scanf("%d%d", &t, &u);
if (t == 1 )//给u到v上的点加k
{
scanf("%d%d", &v, &k);
update_path(u, v, k);
}
else if (t == 2 )//将u为根的子树上所有节点加K
{

## KMP

## 带权并查集

```
scanf("%d", &k);
update_tree(u, k);
}
else if (t == 3 )//询问路径上的权值和
{
scanf("%d", &v);
printf("%lld\n", query_path(u, v));
}
else printf("%lld\n", query_tree(u));//询问u为根的子树上节点权值和
}
return 0 ;
}
```

#### 给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。

#### 模板串 P 在模式串 S 中多次作为子串出现。

#### 求出模板串 P 在模式串 S 中所有出现的位置的起始下标。

```
void solve() {
cin >> n >> p + 1 >> m >> s + 1 ;
//求next过程
for (int i = 2 , j = 0 ; i <= n; i++) {
while (j && p[i] != p[j + 1 ]) {
j = ne[j];
}
if (p[i] == p[j + 1 ])
j++;
ne[i] = j;
}
//匹配过程
for (int i = 1 , j = 0 ; i <= m; i++) {
while (j && s[i] != p[j + 1 ]) { //只要没有退回起点,并且两者不能匹配
j = ne[j]; //跳回去
}
if (s[i] == p[j + 1 ])
j++;//如果两者匹配,就能移动到下一
if (j == n) { //匹配成功
cout << i - n << " ";
j = ne[j];
}
}
}
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
```

## AC自动机

```
using namespace std;
const int N = 3 * 50010 ;
int n, k;
int f[N];
int find(int x) {
return x == f[x]? f[x] : f[x] = find(f[x]);
}
void merge(int x, int y) {
f[find(x)] = find(y);
}
int ans = 0 ;
void solve() {
cin >> n >> k;
for (int i = 1 ; i <= 3 *n; i++)
f[i] = i;
while (k--) {
int d, x, y;
cin >> d >> x >> y;
if (x > n || y > n) {
ans++;
} else if (d == 1 ) { //同类
if (find(x) == find(y + n) || find(x) == find(y+n+n)) {
ans++;
} else {
merge(x, y);
merge(x + n, y + n);
merge(x + n + n, y + n + n);
}
} else { //x吃y
if (x == y || find(x) == find(y) || find(x) == find(y + n)) {
ans++;
} else {
merge(x + n, y);
merge(x, y + n + n);
merge(x + n + n, y + n);
}
}
}
cout << ans << endl;
}
```

#### 每个单词分别在论文中出现多少次。

```
const int N = 1000010 ;
int n;
int tr[N][ 26 ], f[N], idx;
int q[N], ne[N];
char str[N];
int id[ 210 ];
void insert(int x) {
int p = 0 ;
for (int i = 0 ; str[i]; i ++ ) {
int t = str[i] - 'a';
if (!tr[p][t])
tr[p][t] = ++ idx;
p = tr[p][t];
```

## 并查集加速区间填涂

```
f[p] ++ ;
}
id[x] = p;
}
void build() {
int hh = 0 , tt = - 1 ;
for (int i = 0 ; i < 26 ; i ++ )
if (tr[ 0 ][i])
q[ ++ tt] = tr[ 0 ][i];
while (hh <= tt) {
int t = q[hh ++ ];
for (int i = 0 ; i < 26 ; i ++ ) {
int &p = tr[t][i];
if (!p)
p = tr[ne[t]][i];
else {
ne[p] = tr[ne[t]][i];
q[ ++ tt] = p;
}
}
}
}
int main() {
scanf("%d", &n);
for (int i = 0 ; i < n; i ++ ) {
scanf("%s", str);
insert(i);
}
build();
for (int i = idx - 1 ; i >= 0 ; i -- )
f[ne[q[i]]] += f[q[i]];
for (int i = 0 ; i < n; i ++ )
printf("%d\n", f[id[i]]);
return 0 ;
}
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;
int n, m;
const int N = 1e7 + 10 ;
int f[N];//指向一个区间里的主线
struct node {
char val;
int l, r;
} q[N];
char a[N];
bool cmp(node a, node b) {
if (a.val == b.val) {
return a.l < b.l;
}
return a.val > b.val;
}
int find(int x) {
```

## 并查集拓展域

```
return x == f[x]? f[x] : find(f[x]);
}
void solve() {
cin >> n >> m;
for (int i = 1 ; i <= n; i++) {
cin >> a[i];
f[i] = i;
}
for (int i = 1 ; i <= m; i++) {
cin >> q[i].l >> q[i].r >> q[i].val;
}
sort(q + 1 , q + 1 + m, cmp);
for (int i = 1 ; i <= m; i++) {
int l = q[i].l, r = q[i].r;
char ch = q[i].val;
if (find(l) > r)
continue;
for (int i = l; i <= r; i++) {
i = find(i);
if (i > r)
break;
f[i] = max(f[i], r);
a[i] = max(a[i], ch);
}
}
int ans = 0 ;
for (int i = 1 ; i <= n; i++) {
ans += a[i];
}
cout << ans << endl;
}
const int N = 3 * 50010 ;
int n, k;
int f[N];
int find(int x) {
return x == f[x]? f[x] : f[x] = find(f[x]);
}
void merge(int x, int y) {
f[find(x)] = find(y);
}
int ans = 0 ;
void solve() {
cin >> n >> k;
for (int i = 1 ; i <= 3 *n; i++)
f[i] = i;
while (k--) {
int d, x, y;
cin >> d >> x >> y;
if (x > n || y > n) {
ans++;
} else if (d == 1 ) { //同类
if (find(x) == find(y + n) || find(x) == find(y+n+n)) {
ans++;
} else {
```

# 数论

## gcd与exgcd

## 约数

### 约数之和

### 约数个数

```
merge(x, y);
merge(x + n, y + n);
merge(x + n + n, y + n + n);
}
} else { //x吃y
if (x == y || find(x) == find(y) || find(x) == find(y + n)) {
ans++;
} else {
merge(x + n, y);
merge(x, y + n + n);
merge(x + n + n, y + n);
}
}
}
cout << ans << endl;
}
signed main() {
ios::sync_with_stdio(false);
cin.tie( 0 );
cout.tie( 0 );
solve();
}
int gcd(int a, int b)
{
return b? gcd(b, a % b) : a;
}
给定 n 对正整数 ai,bi，对于每对数，求出一组 xi,yi，使其满足 ai×xi+bi×yi=gcd(ai,bi)。
int exgcd(int a, int b, int &x, int &y) {
if (!b) {
x = 1 , y = 0 ;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= a / b * x;
return d;
}
```

## 卡特兰数

### 在任意位置，其前面的 1 的个数大于等于其前面 0 的个数，

## 第一类斯特林数

### 表示将 n个两两不同的元素，划分为 k 个非空圆排列的方案数。

## 第二类斯特林数

### 表示将 n个两两不同的元素，划分为 k 个非空子集的方案数。

## 差分表

### 对于第一项，如果你精通归纳法的话，自然能求出 计算式，但今天我们了解一个神奇的东西: 差分

### 表

### 我们将其一直进行差分，直到有一行全 0 为止，得差分表:

```
const int N = 1010 , MOD = 1e9 + 7 ;
int n, m;
int f[N][N];
int main(){
cin >> n >> m;
f[ 0 ][ 0 ] = 1 ;
for (int i = 1 ; i <= n; i ++ )
for (int j = 1 ; j <= m; j ++ )
f[i][j] = (f[i - 1 ][j - 1 ] + (LL)(i - 1 ) * f[i - 1 ][j]) % MOD;
cout << f[n][m] << endl;
return 0 ;
}
const int N = 1010 , MOD = 1e9 + 7 ;
int n, m;
int f[N][N];
int main()
{
cin >> n >> m;
f[ 0 ][ 0 ] = 1 ;
for (int i = 1 ; i <= n; i ++ )
for (int j = 1 ; j <= m; j ++ )
f[i][j] = (f[i - 1 ][j - 1 ] + (LL)j * f[i - 1 ][j]) % MOD;
cout << f[n][m] << endl;
return 0 ;
}
```

### 我们将差分表的第一列拿出来:

### 于是公式就是:

## BSGS

### 求解 的最小非负x

```
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <unordered_map>
using namespace std;
typedef long long LL;
const int INF = 1e8;
int exgcd(int a, int b, int& x, int& y)
{
if (!b)
{
x = 1 , y = 0 ;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= a / b * x;
return d;
}
int bsgs(int a, int b, int p)
{
if ( 1 % p == b % p) return 0 ;
int k = sqrt(p) + 1 ;
unordered_map<int, int> hash;
for (int i = 0 , j = b % p; i < k; i ++ )
{
hash[j] = i;
j = (LL)j * a % p;
}
int ak = 1 ;
for (int i = 0 ; i < k; i ++ ) ak = (LL)ak * a % p;
for (int i = 1 , j = ak; i <= k; i ++ )
{
if (hash.count(j)) return i * k - hash[j];
j = (LL)j * ak % p;
```

## FFT

#### }

```
return - INF;
}
int exbsgs(int a, int b, int p)
{
b = (b % p + p) % p;
if ( 1 % p == b % p) return 0 ;
int x, y;
int d = exgcd(a, p, x, y);
if (d > 1 )
{
if (b % d) return - INF;
exgcd(a / d, p / d, x, y);
return exbsgs(a, (LL)b / d * x % (p / d), p / d) + 1 ;
}
return bsgs(a, b, p);
}
int main()
{
int a, p, b;
while (cin >> a >> p >> b, a || p || b)
{
int res = exbsgs(a, b, p);
if (res < 0 ) puts("No Solution");
else cout << res << endl;
}
return 0 ;
}
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int N = 300010 ;
const double PI = acos(- 1 );
int n, m;
struct Complex
{
double x, y;
Complex operator+ (const Complex& t) const
{
return {x + t.x, y + t.y};
}
Complex operator- (const Complex& t) const
{
return {x - t.x, y - t.y};
```

## 高斯消元

#### }

```
Complex operator* (const Complex& t) const
{
return {x * t.x - y * t.y, x * t.y + y * t.x};
}
}a[N], b[N];
int rev[N], bit, tot;
void fft(Complex a[], int inv)
{
for (int i = 0 ; i < tot; i ++ )
if (i < rev[i])
swap(a[i], a[rev[i]]);
for (int mid = 1 ; mid < tot; mid <<= 1 )
{
auto w1 = Complex({cos(PI / mid), inv * sin(PI / mid)});
for (int i = 0 ; i < tot; i += mid * 2 )
{
auto wk = Complex({ 1 , 0 });
for (int j = 0 ; j < mid; j ++, wk = wk * w1)
{
auto x = a[i + j], y = wk * a[i + j + mid];
a[i + j] = x + y, a[i + j + mid] = x - y;
}
}
}
}
int main()
{
scanf("%d%d", &n, &m);
for (int i = 0 ; i <= n; i ++ ) scanf("%lf", &a[i].x);
for (int i = 0 ; i <= m; i ++ ) scanf("%lf", &b[i].x);
while (( 1 << bit) < n + m + 1 ) bit ++;
tot = 1 << bit;
for (int i = 0 ; i < tot; i ++ )
rev[i] = (rev[i >> 1 ] >> 1 ) | ((i & 1 ) << (bit - 1 ));
fft(a, 1 ), fft(b, 1 );
for (int i = 0 ; i < tot; i ++ ) a[i] = a[i] * b[i];
fft(a, - 1 );
for (int i = 0 ; i <= n + m; i ++ )
printf("%d ", (int)(a[i].x / tot + 0.5));
return 0 ;
}
#include <bits/stdc++.h>
using namespace std;
const int N = 110 ;
const double eps = 1e- 6 ;
int n;
double a[N][N];
```

int gauss() {
int c, r; //r行 c列
for (c = 0 , r = 0 ; c < n; c++) {
int t = r;
for (int i = r; i < n; i++) { //找到当前这一列绝对值最大的一行
if (fabs(a[i][c]) > fabs(a[t][c])) {
t = i;
}
}
if (fabs(a[t][c]) < eps)
continue;//当前点不需要
for (int i = c; i <= n; i++)
swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i--)
a[r][i] /= a[r][c]; //把第一位变成 1
for (int i = r + 1 ; i < n; i++) {
if (fabs(a[i][c]) > eps) { //不是 0 才去操作
for (int j = n; j >= c; j--) {
a[i][j] -= a[r][j] * a[i][c];
}
}
}
r++;

}
if (r < n) { //消完之后，剩余的个数小于n
for (int i = r; i < n; i++) {
if (fabs(a[i][n]) > eps)
return 2 ;//无解
}
return 1 ;//无穷解
}
for (int i = n - 1 ; i >= 0 ; i--) {
for (int j = i + 1 ; j < n; j++) {
a[i][n] -= a[j][n] * a[i][j];
}
}
return 0 ;//唯一解
}

int main() {
cin >> n;
for (int i = 0 ; i < n; i++) {
for (int j = 0 ; j < n + 1 ; j++) {
cin >> a[i][j];
}
}
int t = gauss();
if (t == 0 ) {
for (int i = 0 ; i < n; i++)
printf("%.2lf\n", a[i][n]);
} else if (t == 1 ) {
puts("Infinite group solutions");
} else {
puts("No solution");
}
return 0 ;
}

## 欧拉函数

## 容斥

```
void solve() {
int x;
cin >> x;
int n = x;
int res = n;
for (int i = 2 ; i <= x / i; i++) {
if (x % i == 0 ) {
while(x%i== 0 )x/=i;
res = res / i * (i - 1 );
}
}
if (x > 1 )
res = res / x * (x - 1 );
cout << res << endl;
}
const int N = 1000010 ;
int primes[N], cnt;
int euler[N];
bool st[N];
void get_eulers(int n) {
euler[ 1 ] = 1 ;
for (int i = 2 ; i <= n; i ++ ) {
if (!st[i]) {
primes[cnt ++ ] = i;
euler[i] = i - 1 ;
}
for (int j = 0 ; primes[j] <= n / i; j ++ ) {
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0 ) {
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1 );
}
}
}
给定一个整数 n 和 m 个不同的质数 p1,p2,...,pm。
请你求出 1 ∼n 中能被 p1,p2,...,pm 中的至少一个数整除的整数有多少个。
const int N = 20 ;
int p[N];
int main() {
int n, m;
cin >> n >> m;
for (int i = 0 ; i < m; i ++ )
cin >> p[i];
int res = 0 ;
for (int i = 1 ; i < 1 << m; i ++ ) {
int t = 1 , s = 0 ;
```

# 计算几何

## 基础

```
for (int j = 0 ; j < m; j ++ )
if (i >> j & 1 ) {
if ((LL)t * p[j] > n) {
t = - 1 ;
break;
}
t *= p[j];
s ++ ;
}
if (t != - 1 ) {
if (s % 2 )
res += n / t;
else
res -= n / t;
}
}
cout << res << endl;
}
```

#### 1. 前置知识点

```
( 1 ) pi = acos(- 1 );
( 2 ) 余弦定理 c^2 = a^2 + b^2 - 2abcos(t)
```

1. 浮点数的比较
   const double eps = 1e- 8 ;
   int sign(double x) // 符号函数
   {
   if (fabs(x) < eps) return 0 ;
   if (x < 0 ) return - 1 ;
   return 1 ;
   }
   int cmp(double x, double y) // 比较函数
   {
   if (fabs(x - y) < eps) return 0 ;
   if (x < y) return - 1 ;
   return 1 ;
   }
2. 向量
   3.1 向量的加减法和数乘运算
   3.2 内积（点积） A·B = |A||B|cos(C)
   ( 1 ) 几何意义：向量A在向量B上的投影与B的长度的乘积。
   ( 2 ) 代码实现
   double dot(Point a, Point b)
   {
   return a.x * b.x + a.y * b.y;
   }
   3.3 外积（叉积） AxB = |A||B|sin(C)
   ( 1 ) 几何意义：向量A与B张成的平行四边形的有向面积。B在A的逆时针方向为正。
   ( 2 ) 代码实现

double cross(Point a, Point b)
{
return a.x * b.y - b.x * a.y;
}
3.4 常用函数
3.4.1 取模
double get_length(Point a)
{
return sqrt(dot(a, a));
}
3.4.2 计算向量夹角
double get_angle(Point a, Point b)
{
return acos(dot(a, b) / get_length(a) / get_length(b));
}
3.4.3 计算两个向量构成的平行四边形有向面积
double area(Point a, Point b, Point c)
{
return cross(b - a, c - a);
}
3.4.5 向量A顺时针旋转C的角度：
Point rotate(Point a, double angle)
{
return Point(a.x * cos(angle) + a.y * sin(angle), -a.x * sin(angle)

- a.y * cos(angle));
  }

1. 点与线
   4.1 直线定理
   ( 1 ) 一般式 ax + by + c = 0
   ( 2 ) 点向式 p0 + vt
   ( 3 ) 斜截式 y = kx + b
   4.2 常用操作
   ( 1 ) 判断点在直线上 A x B = 0
   ( 2 ) 两直线相交
   // cross(v, w) == 0则两直线平行或者重合
   Point get_line_intersection(Point p, Vector v, Point q, vector w)
   {
   vector u = p - q;
   double t = cross(w, u) / cross(v, w);
   return p + v * t;
   }
   ( 3 ) 点到直线的距离
   double distance_to_line(Point p, Point a, Point b)
   {
   vector v1 = b - a, v2 = p - a;
   return fabs(cross(v1, v2) / get_length(v1));
   }
   ( 4 ) 点到线段的距离
   double distance_to_segment(Point p, Point a, Point b)
   {
   if (a == b) return get_length(p - a);
   Vector v1 = b - a, v2 = p - a, v3 = p - b;
   if (sign(dot(v1, v2)) < 0 ) return get_length(v2);
   if (sign(dot(v1, v3)) > 0 ) return get_length(v3);
   return distance_to_line(p, a, b);
   }
   ( 5 ) 点在直线上的投影
   double get_line_projection(Point p, Point a, Point b)

#### {

Vector v = b - a;
return a + v * (dot(v, p - a) / dot(v, v));
}
( 6 ) 点是否在线段上
bool on_segment(Point p, Point a, Point b)
{
return sign(cross(p - a, p - b)) == 0 && sign(dot(p - a, p - b)) <=
0 ;
}
( 7 ) 判断两线段是否相交
bool segment_intersection(Point a1, Point a2, Point b1, Point b2)
{
double c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1);
double c3 = cross(b2 - b1, a2 - b1), c4 = cross(b2 - b1, a1 - b1);
return sign(c1) * sign(c2) <= 0 && sign(c3) * sign(c4) <= 0 ;
}

1. 多边形
   5.1 三角形
   5.1.1 面积
   ( 1 ) 叉积
   ( 2 ) 海伦公式
   p = (a + b + c) / 2 ;
   S = sqrt(p(p - a) * (p - b) * (p - c));
   5.1.2 三角形四心
   ( 1 ) 外心，外接圆圆心
   三边中垂线交点。到三角形三个顶点的距离相等
   ( 2 ) 内心，内切圆圆心
   角平分线交点，到三边距离相等
   ( 3 ) 垂心
   三条垂线交点
   ( 4 ) 重心
   三条中线交点（到三角形三顶点距离的平方和最小的点，三角形内到三边距离之积最大的点）
   5.2 普通多边形
   通常按逆时针存储所有点
   5.2.1 定义
   ( 1 ) 多边形
   由在同一平面且不再同一直线上的多条线段首尾顺次连接且不相交所组成的图形叫多边形
   ( 2 ) 简单多边形
   简单多边形是除相邻边外其它边不相交的多边形
   ( 3 ) 凸多边形
   过多边形的任意一边做一条直线，如果其他各个顶点都在这条直线的同侧，则把这个多边形叫
   做凸多边形
   任意凸多边形外角和均为360°
   任意凸多边形内角和为(n−2) 180 °
   5.2.2 常用函数
   ( 1 ) 求多边形面积（不一定是凸多边形）
   我们可以从第一个顶点除法把凸多边形分成n − 2 个三角形，然后把面积加起来。
   double polygon_area(Point p[], int n)
   {
   double s = 0 ;
   for (int i = 1 ; i + 1 < n; i ++ )
   s += cross(p[i] - p[ 0 ], p[i + 1 ] - p[i]);
   return s / 2 ;
   }
   ( 2 ) 判断点是否在多边形内（不一定是凸多边形）
   a. 射线法，从该点任意做一条和所有边都不平行的射线。交点个数为偶数，则在多边形外，为奇
   数，则在多边形内。

## 代码模板

```
b. 转角法
( 3 ) 判断点是否在凸多边形内
只需判断点是否在所有边的左边（逆时针存储多边形）。
5.3 皮克定理
皮克定理是指一个计算点阵中顶点在格点上的多边形面积公式该公式可以表示为:
S = a + b/ 2 - 1
其中a表示多边形内部的点数，b表示多边形边界上的点数，S表示多边形的面积。
```

1. 圆
   ( 1 ) 圆与直线交点
   ( 2 ) 两圆交点
   ( 3 ) 点到圆的切线
   ( 4 ) 两圆公切线
   ( 5 ) 两圆相交面积

```
double PI = acos(- 1 );
struct Point {
double x, y;
Point(double x = 0 , double y = 0 ): x(x), y(y) {};
};
typedef Point Vector;
const double eps = 1e- 8 ;
int sign(double x) { // 符号函数
if (fabs(x) < eps)
return 0 ;
if (x < 0 )
return - 1 ;
return 1 ;
}
int cmp(double x, double y) { // 比较函数
if (fabs(x - y) < eps)
return 0 ;
if (x < y)
return - 1 ;
return 1 ;
}
Point operator + (Point A, Point B) {
return Point(A.x + B.x, A.y + B.y);
}
Point operator - (Point A, Point B) {
return Point(A.x - B.x, A.y - B.y);
}
Point operator * (Point A, double p) {
return Point(A.x * p, A.y * p);
}
Point operator / (Point A, double p) {
return Point(A.x / p, A.y / p);
}
```

bool operator == (Point A, Point B) {
return !cmp(A.x, B.x) && !cmp(A.y, B.y);
}

//点积,向量A在向量B上的投影与B的长度的乘积
double dot(Point a, Point b) {
return a.x * b.x + a.y * b.y;
}

//外积,向量A与B张成的平行四边形的有向面积
double cross(Point a, Point b) {
return a.x * b.y - b.x * a.y;
}

//取模
double get_length(Point a) {
return sqrt(dot(a, a));
}

//计算向量夹角
double get_angle(Point a, Point b) {
return acos(dot(a, b) / get_length(a) / get_length(b));
}

//计算两个向量构成的平行四边形有向面积
double area(Point a, Point b, Point c) {
return cross(b - a, c - a);
}

//向量A顺时针旋转C的角度：
Point rotate(Point a, double angle) {
return Point(a.x * cos(angle) + a.y * sin(angle), -a.x * sin(angle) + a.y *
cos(angle));
}

// 计算两点交点,cross(v, w) == 0则两直线平行或者重合
Point get_line_intersection(Point p, Vector v, Point q, Vector w) {
Vector u = p - q;
double t = cross(w, u) / cross(v, w);
return p + v * t;
}

//点到直线的距离
double distance_to_line(Point p, Point a, Point b) {
Vector v1 = b - a, v2 = p - a;
return fabs(cross(v1, v2) / get_length(v1));
}

#### //点到线段的距离

double distance_to_segment(Point p, Point a, Point b) {
if (a == b)
return get_length(p - a);
Vector v1 = b - a, v2 = p - a, v3 = p - b;
if (sign(dot(v1, v2)) < 0 )
return get_length(v2);
if (sign(dot(v1, v3)) > 0 )

return get_length(v3);
return distance_to_line(p, a, b);
}

//点在直线上的投影
Point get_line_projection(Point p, Point a, Point b) {
Vector v = b - a;
return a + v * (dot(v, p - a) / dot(v, v));
}

//点是否在线段上
bool on_segment(Point p, Point a, Point b) {
return sign(cross(p - a, p - b)) == 0 && sign(dot(p - a, p - b)) <= 0 ;
}

//判断两线段是否相交
bool segment_intersection(Point a1, Point a2, Point b1, Point b2) {
double c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1);
double c3 = cross(b2 - b1, a2 - b1), c4 = cross(b2 - b1, a1 - b1);
return sign(c1) * sign(c2) <= 0 && sign(c3) * sign(c4) <= 0 ;
}

/*
海伦公式
p = (a + b + c) / 2;
S = sqrt(p(p - a) * (p - b) * (p - c));
*/

/*
求多边形面积（不一定是凸多边形）
我们可以从第一个顶点除法把凸多边形分成n - 2个三角形，然后把面积加起来。
*/
double polygon_area(Point p[], int n) {
double s = 0 ;
for (int i = 1 ; i + 1 < n; i ++ )
s += cross(p[i] - p[ 0 ], p[i + 1 ] - p[i]);
return s / 2 ;
}
/*
根据k,b计算两直线相交交点的x
k1x+b1=k2x+b2
*/

/*
叉乘计算三角形面积
直线经过的整数点个数(不包含首尾) t=gcd(abs(x1-x2),abs(y1-y2))-1;
皮克定理 格点三角形面积 s=n+m/2-1 :m为边界点的数量(包含顶点)
则内部点的个数 n=s-m/2+1;
*/
//计算三角形面积
double area(int a1, int b1, int a2, int b2, int a3, int b3) {
double Ax = a2 - a1;
double Ay = b2 - b1;
double Bx = a3 - a2;
double By = b3 - b2;
return abs((Ax) \* (By) - (Ay) \* (Bx)) / 2 ;
}
/*

## 半平面交

### 逆时针给出 n个凸多边形的顶点坐标，求它们交的面积。

```
平面一点（x1,y1）,绕一点（x0,y0）顺时针旋转 a度
则新的坐标为
x=(x1-x0)*cosa-(y1-y0)*sina+x0;
y=(y1-y0)*cosa+(x1-x0)*sina+y0;
逆时针旋转则是
x=(x1-x0)*cos(-a)-(y1-y0)*sin(-a)+x0;
y=(y1-y0)*cos(-a)+(x1-x0)*sin(-a)+y0;
*/
Point rotate_two_node(Point a, Point b, double angle) { //a为定点,b为旋转点
//angle 是弧度,弧度=角度*PI/180
return {((b.x - a.x)*cos(angle) - (b.y - a.y)*sin(angle) + a.x),
((b.y - a.y)*cos(angle) + (b.x - a.x)*sin(angle) + a.y)};
}
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
#define x first
#define y second
using namespace std;
typedef pair<double,double> PDD;
const int N = 510 ;
const double eps = 1e- 8 ;
int cnt;
struct Line
{
PDD st, ed;
}line[N];
PDD pg[N], ans[N];
int q[N];
int sign(double x)
{
if (fabs(x) < eps) return 0 ;
if (x < 0 ) return - 1 ;
return 1 ;
}
int dcmp(double x, double y)
{
if (fabs(x - y) < eps) return 0 ;
if (x < y) return - 1 ;
return 1 ;
```

#### }

double get_angle(const Line& a)
{
return atan2(a.ed.y - a.st.y, a.ed.x - a.st.x);
}

PDD operator-(PDD a, PDD b)
{
return {a.x - b.x, a.y - b.y};
}

double cross(PDD a, PDD b)
{
return a.x * b.y - a.y * b.x;
}

double area(PDD a, PDD b, PDD c)
{
return cross(b - a, c - a);
}

bool cmp(const Line& a, const Line& b)
{
double A = get_angle(a), B = get_angle(b);
if (!dcmp(A, B)) return area(a.st, a.ed, b.ed) < 0 ;
return A < B;
}

PDD get_line_intersection(PDD p, PDD v, PDD q, PDD w)
{
auto u = p - q;
double t = cross(w, u) / cross(v, w);
return {p.x + v.x * t, p.y + v.y * t};
}

PDD get_line_intersection(Line a, Line b)
{
return get_line_intersection(a.st, a.ed - a.st, b.st, b.ed - b.st);
}

// bc的交点是否在a的右侧
bool on_right(Line& a, Line& b, Line& c)
{
auto o = get_line_intersection(b, c);
return sign(area(a.st, a.ed, o)) <= 0 ;
}

double half_plane_intersection()
{
sort(line, line + cnt, cmp);
int hh = 0 , tt = - 1 ;
for (int i = 0 ; i < cnt; i ++ )
{
if (i && !dcmp(get_angle(line[i]), get_angle(line[i - 1 ]))) continue;
while (hh + 1 <= tt && on_right(line[i], line[q[tt - 1 ]], line[q[tt]]))
tt -- ;

## 最小圆覆盖

### 在一个二维平面上给定 N 个点，请你画出一个最小的能够包含所有点的圆。

```
while (hh + 1 <= tt && on_right(line[i], line[q[hh]], line[q[hh + 1 ]]))
hh ++ ;
q[ ++ tt] = i;
}
while (hh + 1 <= tt && on_right(line[q[hh]], line[q[tt - 1 ]], line[q[tt]]))
tt -- ;
while (hh + 1 <= tt && on_right(line[q[tt]], line[q[hh]], line[q[hh + 1 ]]))
hh ++ ;
q[ ++ tt] = q[hh];
int k = 0 ;
for (int i = hh; i < tt; i ++ )
ans[k ++ ] = get_line_intersection(line[q[i]], line[q[i + 1 ]]);
double res = 0 ;
for (int i = 1 ; i + 1 < k; i ++ )
res += area(ans[ 0 ], ans[i], ans[i + 1 ]);
return res / 2 ;
}
int main()
{
int n, m;
scanf("%d", &n);
while (n -- )
{
scanf("%d", &m);
for (int i = 0 ; i < m; i ++ ) scanf("%lf%lf", &pg[i].x, &pg[i].y);
for (int i = 0 ; i < m; i ++ )
line[cnt ++ ] = {pg[i], pg[(i + 1 ) % m]};
}
double res = half_plane_intersection();
printf("%.3lf\n", res);
return 0 ;
}
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
#define x first
#define y second
using namespace std;
typedef pair<double, double> PDD;
const int N = 100010 ;
const double eps = 1e- 12 ;
const double PI = acos(- 1 );
int n;
```

PDD q[N];
struct Circle
{
PDD p;
double r;
};

int sign(double x)
{
if (fabs(x) < eps) return 0 ;
if (x < 0 ) return - 1 ;
return 1 ;
}

int dcmp(double x, double y)
{
if (fabs(x - y) < eps) return 0 ;
if (x < y) return - 1 ;
return 1 ;
}

PDD operator- (PDD a, PDD b)
{
return {a.x - b.x, a.y - b.y};
}

PDD operator+ (PDD a, PDD b)
{
return {a.x + b.x, a.y + b.y};
}

PDD operator* (PDD a, double t)
{
return {a.x * t, a.y * t};
}

PDD operator/ (PDD a, double t)
{
return {a.x / t, a.y / t};
}

double operator* (PDD a, PDD b)
{
return a.x * b.y - a.y * b.x;
}

PDD rotate(PDD a, double b)
{
return {a.x * cos(b) + a.y * sin(b), -a.x * sin(b) + a.y * cos(b)};
}

double get_dist(PDD a, PDD b)
{
double dx = a.x - b.x;
double dy = a.y - b.y;
return sqrt(dx * dx + dy * dy);
}

## 无double极角序

```
PDD get_line_intersection(PDD p, PDD v, PDD q, PDD w)
{
auto u = p - q;
double t = w * u / (v * w);
return p + v * t;
}
pair<PDD, PDD> get_line(PDD a, PDD b)
{
return {(a + b) / 2 , rotate(b - a, PI / 2 )};
}
Circle get_circle(PDD a, PDD b, PDD c)
{
auto u = get_line(a, b), v = get_line(a, c);
auto p = get_line_intersection(u.x, u.y, v.x, v.y);
return {p, get_dist(p, a)};
}
int main()
{
scanf("%d", &n);
for (int i = 0 ; i < n; i ++ ) scanf("%lf%lf", &q[i].x, &q[i].y);
random_shuffle(q, q + n);
Circle c({q[ 0 ], 0 });
for (int i = 1 ; i < n; i ++ )
if (dcmp(c.r, get_dist(c.p, q[i])) < 0 )
{
c = {q[i], 0 };
for (int j = 0 ; j < i; j ++ )
if (dcmp(c.r, get_dist(c.p, q[j])) < 0 )
{
c = {(q[i] + q[j]) / 2 , get_dist(q[i], q[j]) / 2 };
for (int k = 0 ; k < j; k ++ )
if (dcmp(c.r, get_dist(c.p, q[k])) < 0 )
c = get_circle(q[i], q[j], q[k]);
}
}
printf("%.10lf\n", c.r);
printf("%.10lf %.10lf\n", c.p.x, c.p.y);
return 0 ;
}
#include <bits/stdc++.h>
#define int long long
#define endl '\n'
#define ull unsigned long long
using namespace std;
const ull base = 1000000007 ;
ull p[ 1000000 ];
int n, q, cnt, res, m;
int f[ 100005 ], vis[ 100005 ];
```

int ans[ 500005 ];
int fg;

struct node {
int x, y, id;
bool operator <(const node &t)const {
if (id < t.id)
return true;
else if (id > t.id)
return false;
return y * t.x < x * t.y;
}
} a[ 1000005 ];

node add(int u) {
node t;
t.x = - a[u].y;
t.y = a[u].x;
if (t.x >= 0 ) {
if (t.y >= 0 ) {
t.id = 1 ;
} else {
t.id = 4 ;
}
} else {
if (t.y >= 0 ) {
t.id = 2 ;
} else {
t.id = 3 ;
}
}
return t;
}

void solve() {
cin >> n;
for (int i = 1 ; i <= n; i++) {
cin >> a[i].x >> a[i].y;
if (a[i].x >= 0 ) {
if (a[i].y >= 0 ) {
a[i].id = 1 ;
} else {
a[i].id = 4 ;
}
} else {
if (a[i].y >= 0 ) {
a[i].id = 2 ;
} else {
a[i].id = 3 ;
}
}
}
if (n < 3 ) {
cout << 0 << endl;
return;
}
sort(a + 1 , a + 1 + n);
int res = 0 ;

for (int l = 1 , r = 2 ; l <= n;) {
node pt = add(l);
if (l == r) {
cout << 0 << endl;
return;
}
if (a[r].x * pt.x + a[r].y * pt.y >= 0 ) {
r = (r) % n + 1 ;
} else {
if (l < r) {
res = max({res, r - l, n - (r - l - 1 )});
} else {
res = max({res, r + n - l, n - (r + n - l - 1 )});
}
l++;

}
}
cout << n - res << endl;

}

This is a offline tool, your data stays locally and is not send to any server!

[Feedback & Bug Reports](https://github.com/jzillmann/pdf-to-markdown/issues)