# 制作切片

```go
arr := []int{1, 2, 3, 4, 5}
s := arr[1:3] // 切片 [2, 3]
```

# 排序

```go
import (
    "sort"
)
arr := []int{3, 2, 1, 5, 4}
sort.Ints(arr)

```

对于自订的结构体，需要实现接口

```go
type Person struct {
    Name string
    Age  int
}

type ByAge []Person

func (p ByAge) Len() int           { return len(p) }
func (p ByAge) Less(i, j int) bool { return p[i].Age < p[j].Age }
func (p ByAge) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }

func main() {
    people := []Person{
        {"Bob", 31},
        {"John", 42},
        {"Michael", 17},
        {"Jenny", 26},
    }
    sort.Sort(ByAge(people))
    fmt.Println(people)
}
```

# string与[]byte

string不可变，只能拼接。想要变可以用

```
s:="123"
b:=[]byte(s)
s=string(b)
```

# 注意值拷贝和引用拷贝

```
nums []int
tmp := nums
```

实质上是拷贝了指针，应该使用

```
tmp := make([]int, len(nums))
copy(tmp, nums)
```

# 字符串处理相关

## 判断包含

```go
strings.Contains(s, substr string) bool
```

## 判断出现位置

`Index()` 返回字符串 `str` 在字符串 `s` 中的索引（`str` 的第一个字符的索引），`-1` 表示字符串 `s` 不包含字符串 `str`：

```go
strings.Index(s, str string) int
```

`LastIndex()` 返回字符串 `str` 在字符串 `s` 中最后出现位置的索引（`str` 的第一个字符的索引），`-1` 表示字符串 `s` 不包含字符串 `str`：

```
strings.LastIndex(s, str string) int
```

## 字符串替换

`Replace()` 用于将字符串 `str` 中的前 `n` 个字符串 `old` 替换为字符串 `new`，并返回一个新的字符串，如果 `n = -1` 则替换所有字符串 `old` 为字符串 `new`：

```
strings.Replace(str, old, new string, n int) string
```

# 接口

就像是C++的多态，可以用接口(父指针)指向一个结构体

```go
package main

import "fmt"

type Shaper interface {
	Area() float32
}

type Square struct {
	side float32
}

func (sq *Square) Area() float32 {
	return sq.side * sq.side
}

type Rectangle struct {
	length, width float32
}

func (r Rectangle) Area() float32 {
	return r.length * r.width
}

func main() {

	r := Rectangle{5, 3} // Area() of Rectangle needs a value
	q := &Square{5}      // Area() of Square needs a pointer
	// shapes := []Shaper{Shaper(r), Shaper(q)}
	// or shorter
	shapes := []Shaper{r, q}
	fmt.Println("Looping through shapes for area ...")
	for n, _ := range shapes {
		fmt.Println("Shape details: ", shapes[n])
		fmt.Println("Area of this shape is: ", shapes[n].Area())
	}
}
```

接口也可以嵌套

```go
type ReadWrite interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
}

type Lock interface {
    Lock()
    Unlock()
}

type File interface {
    ReadWrite
    Lock
    Close()
}
```

## 类型断言

如何检测和转换接口变量的类型

通常我们可以使用 **类型断言** 来测试在某个时刻 `varI` 是否包含类型 `T` 的值

```
v := varI.(T)       // unchecked type assertion
```

更安全的方式是使用以下形式来进行类型断言：

```go
if v, ok := varI.(T); ok {  // checked type assertion
    Process(v)
    return
}
// varI is not of type T
```

例子

如果忽略 `areaIntf.(*Square)` 中的 `*` 号，会导致编译错误

```go
package main

import (
	"fmt"
	"math"
)

type Square struct {
	side float32
}

type Circle struct {
	radius float32
}

type Shaper interface {
	Area() float32
}

func main() {
	var areaIntf Shaper
	sq1 := new(Square)
	sq1.side = 5

	areaIntf = sq1
	// Is Square the type of areaIntf?
	if t, ok := areaIntf.(*Square); ok {
		fmt.Printf("The type of areaIntf is: %T\n", t)
	}
	if u, ok := areaIntf.(*Circle); ok {
		fmt.Printf("The type of areaIntf is: %T\n", u)
	} else {
		fmt.Println("areaIntf does not contain a variable of type Circle")
	}
}

func (sq *Square) Area() float32 {
	return sq.side * sq.side
}

func (ci *Circle) Area() float32 {
	return ci.radius * ci.radius * math.Pi
}
```

## 类型判断

接口变量的类型也可以使用一种特殊形式的 `switch` 来检测：**type-switch** 

```go
switch t := areaIntf.(type) {
case *Square:
	fmt.Printf("Type Square %T with value %v\n", t, t)
case *Circle:
	fmt.Printf("Type Circle %T with value %v\n", t, t)
case nil:
	fmt.Printf("nil value: nothing to check?\n")
default:
	fmt.Printf("Unexpected type %T\n", t)
}
```

## 测试一个值是否实现了某个接口

假定 `v` 是一个值，然后我们想测试它是否实现了 `Stringer` 接口，可以这样做

```go
type Stringer interface {
    String() string
}

if sv, ok := v.(Stringer); ok {
    fmt.Printf("v implements String(): %s\n", sv.String()) // note: sv, not v
}
```

## 空接口

**空接口或者最小接口** 不包含任何方法，它对实现不做任何要求：

```go
type Any interface {}
```

可以给一个空接口类型的变量 `var val interface {}` 赋任何类型的值。

## 接口到接口

一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法。这个转换是在运行时进行检查的，转换失败会导致一个运行时错误：这是 `Go` 语言动态的一面，可以拿它和 `Ruby` 和 `Python` 这些动态语言相比较。

# 反射包

反射是用程序检查其所拥有的结构，尤其是类型的一种能力

反射包的 `Type` 用来表示一个 Go 类型，反射包的 `Value` 为 Go 值提供了反射接口。

`reflect.TypeOf` 和 `reflect.ValueOf`，返回被检查对象的**类型**和**值**

```go
var x float64 = 3.4
reflect.TypeOf(x)
```

反射是通过检查一个接口的值，变量首先被转换成空接口。函数签名:

```go
func TypeOf(i interface{}) Type
func ValueOf(i interface{}) Value
```

## 通过反射修改（设置）值

当 `v := reflect.ValueOf(x)` 函数通过传递一个 `x` 拷贝创建了 `v`，那么 `v` 的改变并不能更改原始的 `x`。要想 `v` 的更改能作用到 `x`，那就必须传递 x 的地址 `v = reflect.ValueOf(&x)`。

通过 `Type()` 我们看到 `v` 现在的类型是 `*float64` 并且仍然是不可设置的。

要想让其可设置我们需要使用 `Elem()` 函数，这间接地使用**指针**：`v = v.Elem()`

现在 `v.CanSet()` 返回 `true` 并且 `v.SetFloat(3.1415)` 设置成功了！

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var x float64 = 3.4
	v := reflect.ValueOf(x)
	// setting a value:
	// v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value
	fmt.Println("settability of v:", v.CanSet())
	v = reflect.ValueOf(&x) // Note: take the address of x.
	fmt.Println("type of v:", v.Type())
	fmt.Println("settability of v:", v.CanSet())
	v = v.Elem()
	fmt.Println("The Elem of v is: ", v)
	fmt.Println("settability of v:", v.CanSet())
	v.SetFloat(3.1415) // this works!
	fmt.Println(v.Interface())
	fmt.Println(v)
}
```

## 反射结构

反射一个结构类型,`NumField()` 方法返回结构内的字段数量；通过一个 `for` 循环用索引取得每个字段的值 `Field(i)`。

```go
package main

import (
	"fmt"
	"reflect"
)

type NotknownType struct {
	s1, s2, s3 string
}

func (n NotknownType) String() string {
	return n.s1 + " - " + n.s2 + " - " + n.s3
}

// variable to investigate:
var secret interface{} = NotknownType{"Ada", "Go", "Oberon"}

func main() {
	value := reflect.ValueOf(secret) // <main.NotknownType Value>
	typ := reflect.TypeOf(secret)    // main.NotknownType
	// alternative:
	// typ := value.Type()  // main.NotknownType
	fmt.Println(typ)
	knd := value.Kind() // struct
	fmt.Println(knd)

	// iterate through the fields of the struct:
	for i := 0; i < value.NumField(); i++ {
		fmt.Printf("Field %d: %v\n", i, value.Field(i))
		// error: panic: reflect.Value.SetString using value obtained using unexported field
		// value.Field(i).SetString("C#")
	}

	// call the first method, which is String():
	results := value.Method(0).Call(nil)
	fmt.Println(results) // [Ada - Go - Oberon]
}
```

如果一个结构体实现了Stringer接口的String方法，那么当这个结构体被打印成字符串时，会默认调用这个String方法来生成字符串表示。

结构中只有被导出字段（**首字母大写**）才是可设置的

# 函数重载

函数重载是不被允许的,在 Go 语言中函数重载可以用可变参数 `...T` 作为函数最后一个参数来实现

如果我们把 `T` 换为空接口，那么可以知道任何类型的变量都是满足 `T` (空接口）类型的，这样就允许我们传递任何数量任何类型的参数给函数，即重载的实际含义。

函数 `fmt.Printf` 就是这样做的：

```go
fmt.Printf(format string, a ...interface{}) (n int, errno error)
```

这个函数通过枚举 slice 类型的实参动态确定所有参数的类型，并查看每个类型是否实现了 `String()` 方法，如果是就用于产生输出信息。

# 接口的继承

当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的**指针**时，这个类型就可以使用（另一个类型）所有的接口方法。

例如：

```go
type Task struct {
	Command string
	*log.Logger
}
```

这个类型的工厂方法像这样：

```go
func NewTask(command string, logger *log.Logger) *Task {
	return &Task{command, logger}
}
```

当 `log.Logger` 实现了 `Log()` 方法后，`Task` 的实例 `task` 就可以调用该方法：

```go
task.Log()
```

